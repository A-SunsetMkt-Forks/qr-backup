#!/usr/bin/env python3
"""
Takes a binary file, and outputs a "paper backup": a printable pdf full of QR codes. 

Following the directions in the pdf, the QR codes can be re-scanned or photographed using a webcame to restore the original file.

Requirements to make the PDF: python 'qrcode' library, imagemagick, img2pdf
Requirements to restore from the PDF: zbar (only)
"""
import PIL, PIL.Image, PIL.ImageDraw, PIL.ImageFont, PIL.ImageOps
import base64, datetime, gzip, hashlib, io, logging, math, os, subprocess, sys, qrcode
assert sys.version_info >= (3,6), "Python 3.6 is required. Submit a patch removing f-strings to fix it, sucka!"

HELP='''Usage: qr-codes.py [OPTIONS] FILE
               qr-codes.py --restore [OPTIONS]
               qr-codes.py --restore [OPTIONS] IMAGE [IMAGE ...]
Convert a binary file to a paper .pdf backup of QR codes. With '--restore', read the QR codes in the paper backup using a webcam or scanner, to re-create the original file.

Restore directions are included in the PDF, and do not require qr-backup. Make sure to test that you can actually read the QR size you select.

Backup options:
    --dpi DPI
        Sets the print resolution of your printer. Default: 600
    --compress, --no-compress
        This gives a more compact backup, but partial recovery is impossible. Default: compressed
    --error-correction CORRECTION
        Sets the error correction level. Options are L, M, Q, and H. Default: M (25%)
    --filename FILENAME
        Set the restored filename. Max 32 chars. Default: same as <FILE>
    --output FILENAME, -o FILENAME
        Set the output pdf path (redirecting stdout also works). Default: <FILE>.qr.pdf
    --page WIDTH_POINTS HEIGHT_POINTS
        Sets the usable size of the paper on your printer. This should NOT be 8.5 x 11 -- make sure to include margins. Default: 500x600
    --qr-version VERSION
        Uses QR codes, version VERSION. Versions range from 1-40. The bigger the version, the harder to scan but the more data per code. Default: 10
    --scale SCALE
        Scale QR codes so that each small square in the QR code is SCALE x SCALE pixels. Default: 8

Restore options:
    --code-count COUNT, -c COUNT
        Specify the number of total QR codes. Default: automatic
    --compress, --no-compress
        Force decompression (on/off). Default: automatic
    --image-restore
        Force image-based (scanner) restore. Default: automatic
    --display, --no-display
        For webcam scanning, (display/don't display) a webcam preview. Default: display
    --output FILENAME, -o
        Set the restore file path. Default: stdout
    --sha256 SHA256
        Include a sha256sum to check the file. Default: no check, prints checksum
    --webcam-restore
        Force webcam-based restore. Default: automatic

Options for both:
    --verbose, -v
        Print more detailed information during run

The QR mode is always binary with no QR compression.'''

L = qrcode.constants.ERROR_CORRECT_L
M = qrcode.constants.ERROR_CORRECT_M # default, 25%
Q = qrcode.constants.ERROR_CORRECT_Q
H = qrcode.constants.ERROR_CORRECT_H
MODE = qrcode.util.MODE_8BIT_BYTE # not settable. and no, base64 encoded data doesn't bit in alphanumeric (there are only 44 chars)

VERSIONS_BITS = {
    # Binary bits for each version size, 1-40
    # Source: qrcode.com (DENSO WAVE)
    # Order is L,M,Q,H on right
    1: [152,128,104,72],
    2: [272,224,176,128],
    3: [440,352,272,208],
    4: [640,512,384,288],
    5: [864,688,496,368],
    6: [1088,864,608,480],
    7: [1248,992,704,528],
    8: [1552,1232,880,688],
    9: [1856,1456,1056,800],
    10: [2192,1728,1232,976],
    11: [2592,2032,1440,1120],
    12: [2960,2320,1648,1264],
    13: [3424,2672,1952,1440],
    14: [3688,2920,2088,1576],
    15: [4184,3320,2360,1784],
    16: [4712,3624,2600,2024],
    17: [5176,4056,2936,2264],
    18: [5768,4504,3176,2504],
    19: [6360,5016,3560,2728],
    20: [6888,5352,3880,3080],
    21: [7456,5712,4096,3248],
    22: [8048,6256,4544,3536],
    23: [8752,6880,4912,3712],
    24: [9392,7312,5312,4112],
    25: [10208,8000,5744,4304],
    26: [10960,8496,6032,4768],
    27: [11744,9024,6464,5024],
    28: [12248,9544,6968,5288],
    29: [13048,10136,7288,5608],
    30: [13880,10984,7880,5960],
    31: [14744,11640,8264,6344],
    32: [15640,12328,8920,6760],
    33: [16568,13048,9368,7208],
    34: [17528,13800,9848,7688],
    35: [18448,14496,10288,7888],
    36: [19472,15312,10832,8432],
    37: [20528,15936,11408,8768],
    38: [21616,16816,12016,9136],
    39: [22496,17728,12656,9776],
    40: [23648,18672,13328,10208],
}
def qr_size_chars(version, mode, quality):
    assert mode not in [qrcode.util.MODE_NUMBER, qrcode.util.MODE_KANJI]
    assert mode in [qrcode.util.MODE_ALPHA_NUM, qrcode.util.MODE_8BIT_BYTE]

    bits = VERSIONS_BITS[version][[L,M,Q,H].index(quality)]
    data_bits = bits-4-qrcode.util.length_in_bits(mode, version)
    if mode == qrcode.util.MODE_NUMBER: # Not verified
        return (data_bits//10)*3 + [0,0,0,0,1,1,1,2,2,2][data_bits%10]
    elif mode == qrcode.util.MODE_ALPHA_NUM: # Not verified
        return (data_bits//11)*2 + [0,0,0,0,0,0,1,1,1,1,1][data_bits%11]
    elif mode == qrcode.util.MODE_8BIT_BYTE: # Verified
        return math.floor(data_bits/8)
    elif mode == qrcode.util.MODE_KANJI: # Not verified
        return math.floor(data_bits/13)

def qr_grid_size(version):
    return version*4+17

def generate_chunks(data, chunk_size_base64):
    """
    Return a bunch of chunks to put in QRs.
    The returned values must not contain "\n" due to the use of zbarimg/zbarcam, so we base-64 encode everything at the QR level
    """
    
    num_qrs = 0
    for chunk_digits in range(1, 10):
        prefix_format = "N{:0>" + str(chunk_digits) + "}/{:0>" + str(chunk_digits)+"} "
        payload_size_base64 = chunk_size_base64 - len(prefix_format.format(0,0))
        payload_size_bytes = math.floor(payload_size_base64 / 4) * 3 # groups of 4 base-64 digits encode 3 bytes each
        num_qrs = math.ceil(len(data) / payload_size_bytes)
        if num_qrs <= 10**chunk_digits-1:
            break
    assert math.ceil(len(data)/payload_size_bytes) == num_qrs <= 10**chunk_digits-1
    chunks = []
    for i, start in enumerate(range(0, len(data), payload_size_bytes)):
        prefix = prefix_format.format(i+1, num_qrs).encode('ascii')
        chunk_data_bytes = data[start:start+payload_size_bytes]
        assert len(chunk_data_bytes) <= payload_size_bytes
        chunk_data_base64 = base64.b64encode(chunk_data_bytes)
        assert len(chunk_data_base64) <= payload_size_base64
        chunk_content = prefix+chunk_data_base64
        assert len(chunk_content) <= chunk_size_base64
        chunks.append(chunk_content)
    assert len(chunks) == num_qrs
    return chunk_digits, chunks

def qr_codes(data, error_correction, version, scale):
    naive_chunk_size = qr_size_chars(version, MODE, error_correction)
    chunk_digits, chunks = generate_chunks(data, naive_chunk_size)
    
    qrs = []
    for chunk in chunks:
        qr = qrcode.QRCode(
            version=version,
            error_correction=error_correction,
            box_size=scale,
        )
        assert len(chunk) <= naive_chunk_size
        qr.add_data(qrcode.util.QRData(chunk, mode=MODE), optimize=0)
        qr.make(fit=False)
        qrs.append(qr)

    return chunk_digits, qrs

def show_help(error=None):
    if error:
        print(HELP, file=sys.stderr)
        print(file=sys.stderr)
        print("ERROR: {}".format(error), file=sys.stderr)
        sys.exit(1)
    else:
        print(HELP)
        sys.exit(0)

def add_label(image, text, side="bottom", max_fontsize=24, max_width=None, label=None):
    """
    Add a label. The fontsize is max_fontsize if possible, otherwise it's shrunk down.
    The label is aligned to the bounding box of the image (lines up with margins).
    """
    # Figure out the size and position of the original image
    bbox = PIL.ImageOps.invert(image.copy().convert("L")).getbbox()
    if bbox is None:
        left, upper, right, lower = 0,0,0,0
        if max_width is None:
            max_width = image.size[0]
    elif max_width is None:
        left, upper, right, lower = bbox
        max_width = right-left
    else:
        left, upper, right, lower = bbox
        right, max_width = max(right, max_width), max_width-left

    # Generate a label that fits. The fontsize will be reduced if needed. No word wrap is performed.
    if label is None:
        label = generate_label(text, max_width=max_width, max_fontsize=max_fontsize)
    else:
        assert label.size[0] <= max_width, "Premade label is too wide"
    label_bbox = PIL.ImageOps.invert(image.copy().convert("L")).getbbox()

    # Layout
    width, combined_height = max(image.size[0], left+label.size[0]), image.size[1] + label.size[1]
    labeled = PIL.Image.new(mode="1", size=(width, combined_height), color=1) #B+W
    if side == "bottom":
        labeled.paste(image, (0,0))
        labeled.paste(label, (left,image.size[1]))
    elif side == "top":
        labeled.paste(label, (left,0))
        labeled.paste(image, (0,label.size[1]))
    else:
        assert False, "Unknown side for label: {}".format(side)
    return labeled

def generate_label(text, max_width, max_fontsize=24):
    # to do, maybe some fancy word wrap
    test_im = PIL.Image.new(mode="1", size=(1,1), color=1)
    test_draw = PIL.ImageDraw.Draw(test_im)

    for fontsize in range(max_fontsize, 3, -1):
        font = PIL.ImageFont.truetype("DejaVuSans.ttf", fontsize)
        width, height = test_draw.multiline_textsize(text, font=font)
        height += 4
        if width <= max_width:
            #logging.info("Printing label at font size " + str(fontsize))
            im = PIL.Image.new(mode="1", size=(width, height), color=1) # black-and-white
            draw = PIL.ImageDraw.Draw(im)
            draw.multiline_text((0,-2), text, font=font) # Eurgh, hardcoding an offset.
            return im
    #assert False
    logging.error("Label cannot fit in the requested width. Forcing output...")
    font = PIL.ImageFont.truetype("DejaVuSans.ttf", 12)
    im = PIL.Image.new(mode="1", size=bbox, color=1) # black-and-white
    draw = PIL.ImageDraw.Draw(im)
    draw.multiline_text((0,0), text)
    return im

def h_merge(images):
    # Alignment is top-aligned
    combined_width = sum(image.size[0] for image in images)
    max_height = max(image.size[1] for image in images)
    im = PIL.Image.new(mode="1", size=(combined_width, max_height), color=1) #B+W
    width = 0
    for source_image in images:
        im.paste(source_image,(width, 0))
        width += source_image.size[0]
    return im

def v_merge(images):
    # Alignment is left-aligned
    max_width = max(image.size[0] for image in images)
    combined_height = sum(image.size[1] for image in images)
    im = PIL.Image.new(mode="1", size=(max_width, combined_height), color=1) #B+W
    height = 0
    for source_image in images:
        im.paste(source_image,(0, height))
        height += source_image.size[1]
    return im

def main_backup(args):
    # default settings
    qr_version = 10
    error_correction = M # default, 25%
    scale = 8
    dpi = 300
    page_w_points, page_h_points = 500,600
    restore_file = None
    use_compression = True
    output_path = None
    GENERATE_DOCS = False # Manually generate example.png for the README when qr-backup changes

    # parse arguments
    pargs = []
    while len(args) > 0:
        arg, args = args[0], args[1:]
        if arg in ["-h", "--help"]:
            show_help()
        elif arg == "--compress":
            use_compression = True
        elif arg == "--dpi":
            if len(args) < 1:
                show_help("--dpi requires one argument (an integer dots-per-inch)")
            dpi, args = int(args[0]), args[1:]
        elif arg == "--error-correction":
            if len(args) < 1:
                show_help("--error-correction requires one of: L M Q H")
            error_correction, args = {"L":L, "M": M, "Q": Q, "H": H}[args[0].upper()], args[1:]
        elif arg == "--filename":
            if len(args) < 1:
                show_help("--filename requires one argument")
            restore_file, args = args[0], args[1:]
            assert len(restore_file) > 0 and not restore_file.startswith("-")
        elif arg == "--generate-docs": # Development only. Don't document or use please.
            GENERATE_DOCS=True
        elif arg == "--no-compress":
            use_compression = False
        elif arg == "--page":
            if len(args) < 2:
                show_help("--page requires two arguments (decimal page width and height in inches)")
            page_w_points, page_h_points, args = float(args[0]), float(args[1]), args[2:]
        elif arg in ["-o", "--output"]:
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            output_path, args = args[0], args[1:]
        elif arg == "--qr-version":
            if len(args) < 1:
                show_help("--qr-version requires one argument (integer version between 2 and 40)")
            qr_version, args = int(args[0]), args[1:]
        elif arg == "--scale":
            if len(args) == 0:
                show_help("--scale requires one argument (integer scale in pixels)")
            scale, args = int(args[0]), args[1:]
        elif arg in ["-v", "--verbose"]:
            logging.basicConfig(level=logging.INFO)
        elif arg == "-":
            pargs.append(arg)
        elif arg == "--":
            # Stop parsing arguments
            pargs, args = pargs + args, []
        elif arg.startswith("-"):
            show_help()
        else:
            pargs.append(arg)
    if len(pargs) < 1:
        show_help("Please supply a filename to backup")
    elif len(pargs) > 1:
        show_help("Multiple filenames given. qr-backup can only back up one file at a time")
    input_path, = pargs

    use_stdout = (output_path is None) and not sys.stdout.isatty()
    use_stdin = (input_path == "-")
    if restore_file is None:
        input_filename = input_path.split("/")[-1]
        if not use_stdin and len(input_filename) <= 32:
            restore_file = input_filename
        else:
            restore_file = "file"
    if output_path is None:
        if use_stdin:
            output_path = f"{restore_file or 'stdin'}.qr.pdf"
        else:
            output_path = input_path+".qr.pdf"

    nice_cmd = ' '.join([x for x in ["qr-backup", "--qr-version", str(qr_version), "--dpi", str(dpi), "--scale", str(scale), "--error-correction", "LMQH"[error_correction], "--page", str(page_w_points), str(page_h_points), '--compress' if use_compression else '--no-compress', "--filename", restore_file] if x is not None])
    if GENERATE_DOCS:
        backup_date = "2021-06-15"
    else:
        backup_date = datetime.date.today().strftime("%Y-%m-%d")
    logging.info("Original arguments were: {}".format(repr(args)))
    logging.info("Command arguments parsed. Equivalent command: {}".format(nice_cmd))

    # open the file (or stdin, if "-" is passed as the file)
    if use_stdin:
        f = sys.stdin.buffer
    else:
        f = open(input_path, "rb")

    # read the entire file into memory
    try:
        content = f.read()
    finally:
        f.close()
    sha256sum = hashlib.sha256(content).hexdigest()
    original_len = len(content)
    logging.info(f"read file {restore_file} (sha {sha256sum}, {original_len/1000}KB)")

    # (Gzip) Compression
    if use_compression:
        content = gzip.compress(content, mtime=0)

    # Generate QR codes
    code_digits, qrs = qr_codes(content, error_correction=error_correction, version=qr_version, scale=scale)

    # How to restore
    restore_cmd = f'sort -u | grep "^N" | cut -c{code_digits*2+4}- | base64 -d'
    if use_compression:
        restore_cmd += ' | gunzip'
    logging.info(f"Restore command is: {restore_cmd}")

    # Instructions depend on the command line options, and the content of the file
    HOWTO = f'This is a paper backup of a computer file called: {restore_file}'
    HOWTO += '\nTo restore this file using qr-backup:'
    HOWTO += f'\n  Step 1 (webcam): qr-backup --restore'
    HOWTO += f'\n  Step 1 (scanner): qr-backup --restore IMAGE1 IMAGE2 ...'
    HOWTO += '\nTo restore this file from the command line in Linux:'
    HOWTO += f'\n  Step 1 (webcam option): zbarcam --raw | tee /tmp/qrs | cut -c1-{code_digits+1} # Scan each code at least once in any order'
    HOWTO += f'\n  Step 1 (scanner option): zbarimg -q --raw *.png >/tmp/qrs'
    howto_restore_cmd = restore_cmd.replace("sort -u", "sort -u /tmp/qrs")
    HOWTO += f'\n  Step 2 (restore): {howto_restore_cmd} >{restore_file}'
    HOWTO += f'\n  Step 3 (verify): sha256sum {restore_file} # {sha256sum}'
    HOWTO += f'\nThis backup was generated on {backup_date} with: {nice_cmd}'

    # Calculate QR padding produced by qrcode module
    example_qr = qrs[0].make_image().copy()
    qr_bbox = PIL.ImageOps.invert(example_qr.copy().convert("L")).getbbox()
    qr_lpad, qr_tpad, qr_rpad, qr_bpad = qr_bbox[0], qr_bbox[1], example_qr.size[0]-qr_bbox[2], example_qr.size[1]-qr_bbox[3]
    qr_hpad, qr_vpad = qr_lpad + qr_rpad, qr_tpad + qr_bpad

    # Output QR codes with labels to Pillow Image objects
    labeled = []
    for i, qr in enumerate(qrs):
        img = qr.make_image()
        label = f"code {i+1:0>{code_digits}}/{len(qrs):0>{code_digits}} {restore_file}"
        labeled.append(add_label(img, label))
    logging.info(f"{len(qrs)} qr codes (at version {qr_version}) total")

    # Figure out page layout now that we know the size and number of QR codes. Output to the user.
    qr_w_pixel, qr_h_pixel = labeled[0].size
    logging.info(f"QR code (including label) is: {qr_w_pixel}x{qr_w_pixel}px")

    page_w_pixel, page_h_pixel = math.floor(page_w_points/72.0*dpi), math.floor(page_h_points/72.0*dpi) # 1 "dot" = 1 pixel. !!important note, DPI is not used yet, which is probably some config bug in Pillow
    logging.info(f"Page is: {page_w_pixel}x{page_h_pixel}px")

    howto_label = generate_label(HOWTO, page_w_pixel - qr_hpad)
    howto_height = howto_label.size[1]
    
    page_w_qr, page_h_qr = math.floor((page_w_pixel-2) // qr_w_pixel), math.floor((page_h_pixel-2-howto_height) // qr_h_pixel)
    qr_per_page = page_w_qr * page_h_qr
    if qr_per_page == 0:
        logging.error("Not even 1 QR fits on the given page. Forcing output anyway...")
        page_w_qr, page_h_qr, qr_per_page = 1,1,1
    num_pages = math.ceil(len(qrs)/qr_per_page)
    logging.info(f"{page_w_qr} x {page_h_qr} qr codes (at version {qr_version}) per page. {num_pages} pages total")

    density = original_len / num_pages
    logging.info(f"{len(content)} bytes in {num_pages} ({density/1000:.2f}KB/page)")

    # Combine rows
    rows = []
    for row_start in range(0, len(qrs), page_w_qr):
        row_qrs = labeled[row_start:row_start+page_w_qr]
        rows.append(h_merge(row_qrs))

    # Use imagemagick to make one png file per page-side
    unnumbered_pages = []
    for page_num, page_start in enumerate(range(0, len(rows), page_h_qr)):
        page_rows = rows[page_start:page_start+page_h_qr]
        page_qrs = v_merge(page_rows)
        page_complete = add_label(page_qrs, HOWTO, side="top", max_fontsize=24, max_width=page_w_pixel-2)

        if GENERATE_DOCS:
            page_h_pixel = page_complete.size[1]+2
        page = PIL.Image.new(mode="1", size=(page_w_pixel, page_h_pixel), color=1)
        page_draw = PIL.ImageDraw.Draw(page)
        page_draw.rectangle(((0,0), (page_w_pixel-1, page_h_pixel-1)), outline=0, fill=1, width=1) # Rectangle for debugging print cutoff, and to look nice.
        page.paste(page_complete, (1,1)) # Main contents
        unnumbered_pages.append(page)

    # Add page numbers after. Currently page-numbering is perfectly reliable, but we're about to add more complicated layout options.
    pages = []
    num_pages = len(unnumbered_pages)
    for page_num, page in enumerate(unnumbered_pages):
        page_num = generate_label("page {}/{}".format(page_num+1, num_pages), max_width=example_qr.size[0]/2)
        page.paste(page_num, (page.size[0]-page_num.size[0]-1-qr_rpad, page.size[1]-page_num.size[1]-11)) # Page num in bottom-right
        pages.append(page)

    # PIL's pdf writer needs to mmap, so it can't accept sys.stdout directly
    tmp_pdf = io.BytesIO()
    pages[0].save(tmp_pdf, format="pdf", save_all=True, append_images=pages[1:], resolution=dpi, producer="qr-backup", title=f"qr-backup paper backup of {restore_file} with sha256 {sha256sum} and length {original_len}", creationDate=backup_date, modDate=backup_date)

    if use_stdout: 
        # Write PDF to stdout
        sys.stdout.buffer.write(tmp_pdf.getbuffer())
    else:
        # Write PDF to file
        with open(output_path, "wb") as f:
            f.write(tmp_pdf.getbuffer())

    if use_stdout or use_stdin:
        # Can't test restore yet
        logging.warning("Automatic digital restore skipped because qr-backup is being used in a pipe.")
    else:
        # Test restore
        zbarimg_present = subprocess.call(["which", "zbarimg"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0

        if zbarimg_present:
            logging.info("Performing linux CLI restore check...")
            linux_test_command = "zbarimg --raw -q -Sdisable -Sqrcode.enable {} | {} | cmp {}".format(output_path, restore_cmd, input_path)
            linux_success = (subprocess.call(linux_test_command, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0)
            logging.info("Performing qr-backup restore check...")
            self_test_command = ["python3", sys.argv[0], "--restore", "--sha256", sha256sum, output_path]
            self_test_success = (subprocess.call(self_test_command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0)

            if not linux_success:
                logging.error("!!Automatic digital restore verification FAILED (linux CLI). This indicates a bug in either zbarimg (more likely) or in qr-backup. Please report this to the author at https://github.com/za3k/qr-backup/issues")
                #sys.exit(1)
            elif not self_test_success:
                logging.error("!!Automatic digital restore verification FAILED (self-test). This indicates a bug in qr-backup. Please report this to the author at https://github.com/za3k/qr-backup/issues")
                #sys.exit(1)
            else:
                logging.info("Automatic digital restore verification succeeded.")
        else:
                logging.warning("Attempted digital restore verification, but zbarimg was not available")

    if GENERATE_DOCS:
        pages[0].save("docs/example.png")
        with open("docs/USAGE.md", "w") as f:
            f.write("Output of `qr-backup --help`:\n")
            f.write("\n")
            f.write("```\n")
            f.write(HELP)
            f.write("\n")
            f.write("```\n")

def image_restore(image_paths):
    # Special note: image_paths can include "-", in which case zbarimg will magically do the right thing
    zbarimg_present = subprocess.call(["which", "zbarimg"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0
    if not zbarimg_present:
        logging.fatal("zbarimg not present. install 'zbar' to scan files.")
        sys.exit(2)

    scan_command = ["zbarimg", "--raw", "-q", "-Sdisable", "-Sqrcode.enable"] + image_paths
    result = subprocess.run(scan_command, capture_output=True)
    for line in result.stdout.split(b"\n"):
        if line != b'':
            yield line

def webcam_restore(use_display):
    zbarimg_present = subprocess.call(["which", "zbarcam"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0
    if not zbarimg_present:
        logging.fatal("zbarcam not present. install 'zbar' to scan using your camera.")
        sys.exit(2)

    scan_command = ["zbarcam", "--raw", "-Sdisable", "-Sqrcode.enable"]
    if not use_display:
        scan_command.append("--nodisplay")

    with subprocess.Popen(scan_command, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL) as proc:
        while True:
            line = proc.stdout.readline()
            if line == b'':
                return
            if (yield line):
                return

def expected_codes(codes, code_count): # Returns a list of binary strings
    code_digits = math.ceil(math.log(code_count+1,10))
    return [f"N{i:>0{code_digits}}".encode('ascii') for i in range(1, code_count+1)]
def restore_status(codes, code_count):
    if code_count is None:
        return f"{len(codes)}/??? codes read"
    else:
        missing = [x.decode('ascii') for x in expected_codes(codes, code_count) if x not in codes]
        return f"Missing {len(missing)}/{code_count} codes: " + ' '.join(x[1:] for x in missing[:5]) + (" ..." if len(missing) > 5 else "")
def is_complete(codes, code_count):
    if code_count is None:
        return False
    return all(x in codes for x in expected_codes(codes, code_count))
def do_restore(codes, code_count, use_compression):
    assert is_complete(codes, code_count)

    # Base-64 decoding is per-qr-code
    decoded = {k: base64.b64decode(v) for k,v in codes.items()}

    # Concat
    content = b''.join(decoded[x] for x in expected_codes(codes, code_count))

    if use_compression is True:
        content = gzip.decompress(content)
    elif use_compression is None: # automatic determination
        try:
            content = gzip.decompress(content)
            use_compression = True
        except gzip.BadGzipFile:
            use_compression = False
    return content

def main_restore(args):
    # Default config
    restore_method = None # Should be one of: None, "webcam", "images"

    output_path = None # Should be one of: None (for use_stdout), file path
    use_stdout = False
    code_count = None # Should be one of: None (infer) or a number
    use_display = True

    expected_sha256sum = None
    use_compression = None

    # Parse command-line arguments
    pargs = []
    while len(args) > 0:
        arg, args = args[0], args[1:]
        if arg in ["-h", "--help"]:
            show_help()
        elif arg == "--code-count":
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            code_count, args = int(args[0]), args[1:]
        elif arg == "--compress":
            use_compression = True
        elif arg == "--display":
            use_display = True
        elif arg == "--image-restore":
            restore_method = "images"
        elif arg == "--no-compress":
            use_compression = False
        elif arg == "--no-display":
            use_display = False
        elif arg in ["-o", "--output"]:
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            output_path, args = args[0], args[1:]
        elif arg == "--sha256":
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            expected_sha256sum, args = args[0].lower(), args[1:]
            if not all(x in "0123456789abcdef" for x in expected_sha256sum):
                show_help("Not a valid SHA256: {}".format(expected_sha256sum))
        elif arg in ["-v", "--verbose"]:
            logging.basicConfig(level=logging.INFO)
        elif arg == "--webcam-restore":
            restore_method = "webcam"
        elif arg == "-":
            pargs.append(arg)
        elif arg == "--":
            # Stop parsing arguments
            pargs, args = pargs + args, []
        elif arg.startswith("-"):
            show_help()
        else:
            pargs.append(arg)

    assert len([x for x in pargs if x == "-"]) <= 1, "stdin can be listed as an image only once"
    if restore_method is None and len(pargs) == 0 and not sys.stdin.isatty():
        logging.debug("Reading from stdin")
        restore_method = "images"
        pargs = ["-"]
    elif restore_method is None and len(pargs) == 0:
        restore_method = "webcam"
    elif restore_method is None and len(pargs) > 0:
        restore_method = "images"

    if output_path is None:
        use_stdout = True

    # Call a subprocess to do the restore
    if restore_method == "images":
        logging.info("image restore selected")
        restore_generator = image_restore(pargs)
    elif restore_method == "webcam":
        logging.info("webcam restore selected")
        restore_generator = webcam_restore(use_display=use_display)
    else:
        assert False

    # Scan codes one at a time until done
    codes = {}
    while not is_complete(codes, code_count):
        # Print status line
        if restore_method == "webcam":
            if code_count is None:
                print("Hold up QR codes to the webcam in any order.",file=sys.stderr)
            else:
                print(restore_status(codes, code_count),file=sys.stderr)

        # Read the next code as binary data
        try:
            read_code = next(restore_generator)
        except StopIteration:
            logging.fatal("Not enough codes could be read to restore the file. Exiting.")
            sys.exit(3)

        # Parse the label out
        assert b"\n" not in read_code
        code_label, content = read_code.split(b' ', maxsplit=1)
        code_num, total = code_label.split(b'/')
        total = int(total.decode('ascii'))
        if code_count is None:
            code_count = total
        elif code_count == total:
            pass
        elif code_count != total and len(codes) == 0:
            logging.fatal("Code count disagrees with --code-count option (Code={}, --code-count={})".format(code_label.decode('ascii'), code_count))
            sys.exit(4)
        elif code_count != total and len(codes) != 0:
            logging.fatal("Code count disagrees for codes: {} & {}".format(code, next(iter(code.keys()))))
            sys.exit(4)
        else:
            assert False
        assert code_count is not None

        # Add the code
        if code_num in codes and codes[code_num] == content:
            logging.info(f"Read duplicate code {code_num}: IDENTICAL")
        elif code_num in codes and codes[code_num] != content:
            logging.error(f"Read duplicate code {code_num}: DIVERGES")
        elif code_num not in codes:
            logging.info(f"Read new code {code_num}")
        else:
            assert False
        codes[code_num] = content
    # Close subprocess
    # TODO: Sometimes one extra code needs to be read before it closes, fix that.
    next(restore_generator, True)

    # Do the restore
    content = do_restore(codes, code_count, use_compression=use_compression)

    # Check the checksum
    sha256sum = hashlib.sha256(content).hexdigest()
    exit_status = 0
    logging.info("restored sha256sum: {}".format(sha256sum))
    if expected_sha256sum is None:
        logging.debug("no expected sha256sum was given")
        print(f"sha256sum was as follows, please check against your paper backup: {sha256sum}", file=sys.stderr)
    elif expected_sha256sum == sha256sum:
        logging.debug("sha256sum matched")
        #print("File verified using sha256 checksum.", file=sys.stderr)
    elif sha256sum.startswith(expected_sha256sum):
        logging.debug("sha256sum partial matched")
        print(f"The actual sha256sum begins with checksum given on the command line, but it was not complete. The full checksum was: {sha256sum}", file=sys.stderr)
    else:
        logging.error("sha256sum did not match")
        exit_status = 4
        print(f"!!The restored file does NOT match the expected checksum. Restoring anyway.", file=sys.stderr)

    # Write the output
    if use_stdout:
        sys.stdout.buffer.write(content)
    else:
        with open(output_path, "wb") as f:
            f.write(content)
    sys.exit(exit_status)

if __name__ == "__main__":
    # parse command-line arguments
    args = sys.argv[1:]
    if len(args) > 1 and args[0] in ["-r", "--restore"]:
        main_restore(args[1:])
    else:
        main_backup(args)
