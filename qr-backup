#!/usr/bin/env python3
"""
Takes a binary file, and outputs a "paper backup": a printable pdf full of QR codes. 

Following the directions in the pdf, the QR codes can be re-scanned or photographed using a webcame to restore the original file.

Requirements to make the PDF: python 'qrcode' library, imagemagick, img2pdf
Requirements to restore from the PDF: zbar (only)
"""
import PIL, PIL.Image, PIL.ImageDraw, PIL.ImageFont, PIL.ImageOps
import base64, datetime, gzip, hashlib, logging, math, os, subprocess, sys, qrcode
assert sys.version_info >= (3,6), "Python 3.6 is required. Submit a patch removing f-strings to fix it, sucka!"

HELP='''Usage: qr-codes.py [OPTIONS] FILE
Convert a binary file to a paper .pdf backup of QR codes.

The QR codes can be read back with a scanner or webcam to re-create the original file. Directions are included in the PDF. Make sure to test that you can actually read the QR size you select.

    --dpi DPI
        Sets the print resolution of your printer. Default: 600
    --compress, --no-compress
        This gives a more compact backup, but partial recovery is impossible. Turns base-64 encoding on. Default: compressed
    --error-correction CORRECTION
        Sets the error correction level. Options are L, M, Q, and H. Default: M (25%)
    --filename FILENAME
        Set the restored filename. Max 32 chars. Default: same as <FILE>
    --page WIDTH_POINTS HEIGHT_POINTS
        Sets the usable size of the paper on your printer. This should NOT be 8.5 x 11 -- make sure to include margins. Default: 500x600
    --qr-version VERSION
        Uses QR codes, version VERSION. Versions range from 1-40. The bigger the version, the harder to scan but the more data per code. Default: 10
    --scale SCALE
        Scale QR codes so that each small square in the QR code is SCALE x SCALE pixels. Default: 8
    --base64
        Force base64 encoding. Default: turned on if needed
    --verbose, -v
        Print more detailed information during run

The QR mode is always binary with no QR compression.

The output is named <FILE>.qr.pdf. You can also pipe stdout.'''

L = qrcode.constants.ERROR_CORRECT_L
M = qrcode.constants.ERROR_CORRECT_M # default, 25%
Q = qrcode.constants.ERROR_CORRECT_Q
H = qrcode.constants.ERROR_CORRECT_H

VERSIONS = {
    # Binary bytes for each version size, 1-40
    # Source: qrcode.com (DENSO WAVE)
    # Order is L,M,Q,H on right
    1: [17,14,11,7],
    2: [32,26,20,14],
    3: [53,42,32,24],
    4: [78,62,46,34],
    5: [106,84,60,44],
    6: [134,106,74,58],
    7: [154,122,86,64],
    8: [192,152,108,84],
    9: [230,180,130,98],
    10: [271,213,151,119],
    11: [321,251,177,137],
    12: [367,287,203,155],
    13: [425,331,241,177],
    14: [458,362,258,194],
    15: [520,412,292,220],
    16: [586,450,322,250],
    17: [644,504,364,280],
    18: [718,560,394,310],
    19: [792,624,442,338],
    20: [858,666,482,382],
    21: [929,711,509,403],
    22: [1003,779,565,439],
    23: [1091,857,611,461],
    24: [1171,911,661,511],
    25: [1273,997,715,535],
    26: [1367,1059,751,593],
    27: [1465,1125,805,625],
    28: [1528,1190,868,658],
    29: [1628,1264,908,698],
    30: [1732,1370,982,742],
    31: [1840,1452,1030,790],
    32: [1952,1538,1112,842],
    33: [2068,1628,1168,898],
    34: [2188,1722,1228,958],
    35: [2303,1809,1283,983],
    36: [2431,1911,1351,1051],
    37: [2563,1989,1423,1093],
    38: [2699,2099,1499,1139],
    39: [2809,2213,1579,1219],
    40: [2953,2331,1663,1273],
}
VERSION_TO_BYTES = {
    quality: {version: sizes[place] for version, sizes in VERSIONS.items()} for place, quality in enumerate([L,M,Q,H])
}

def grid_size(version):
    return version*4+17

def qr_codes(data, error_correction, version, scale):
    naive_chunk_size = VERSION_TO_BYTES[error_correction][version]
    for chunk_digits in range(1, 10):
        prefix_format = "{:0>" + str(chunk_digits) + "}"
        chunk_size = naive_chunk_size -len(prefix_format.format(0))
        if len(data) / chunk_size < 10**chunk_digits-1:
            break
    assert len(data) / chunk_size < 10**chunk_digits-1
    
    qrs = []
    for start in range(0, len(data), chunk_size):
        qr = qrcode.QRCode(
            version=version,
            error_correction=error_correction,
            box_size=scale,
        )
        chunk = prefix_format.format(start//chunk_size+1).encode('ascii') + data[start:start+chunk_size]
        qr.add_data(qrcode.util.QRData(chunk, mode=MODE), optimize=0)
        qr.make(fit=False)
        qrs.append(qr)
    assert len(qrs) < 1000
    return chunk_digits, qrs

def show_help(status=1):
    print(HELP)
    sys.exit(status)

def add_label(image, text, side="bottom", max_fontsize=24, label=None):
    """
    Add a label. The fontsize is max_fontsize if possible, otherwise it's shrunk down.
    The label is aligned to the bounding box of the image (lines up with margins).
    """
    # Figure out the size and position of the original image
    bbox = PIL.ImageOps.invert(image.copy().convert("L")).getbbox()
    if bbox is None:
        max_width = image.size[0]
        left, upper, right, lower = 0,0,0,0
    else:
        left, upper, right, lower = bbox
        max_width = right-left

    # Generate a label that fits. The fontsize will be reduced if needed. No word wrap is performed.
    if label is None:
        label = generate_label(text, max_width=image.size[0], max_fontsize=max_fontsize)
    else:
        assert label.size[0] <= max_width, "Premade label is too wide"
    label_bbox = PIL.ImageOps.invert(image.copy().convert("L")).getbbox()

    # Layout
    width, combined_height = image.size[0], image.size[1] + label.size[1]
    labeled = PIL.Image.new(mode="1", size=(image.size[0], combined_height), color=1) #B+W
    if side == "bottom":
        labeled.paste(image, (0,0))
        labeled.paste(label, (left,image.size[1]))
    elif side == "top":
        labeled.paste(label, (left,0))
        labeled.paste(image, (0,label.size[1]))
    else:
        assert False, "Unknown side for label: {}".format(side)
    return labeled

def generate_label(text, max_width, max_fontsize=24):
    # to do, maybe some fancy word wrap
    test_im = PIL.Image.new(mode="1", size=(1,1), color=1)
    test_draw = PIL.ImageDraw.Draw(test_im)

    for fontsize in range(max_fontsize, 3, -1):
        font = PIL.ImageFont.truetype("DejaVuSans.ttf", fontsize)
        width, height = test_draw.multiline_textsize(text, font=font)
        height += 4
        if width <= max_width:
            #logging.info("Printing label at font size " + str(fontsize))
            im = PIL.Image.new(mode="1", size=(width, height), color=1) # black-and-white
            draw = PIL.ImageDraw.Draw(im)
            draw.multiline_text((0,-2), text, font=font) # Eurgh, hardcoding an offset.
            return im
    #assert False
    logging.error("Label cannot fit in the requested width. Forcing output...")
    font = PIL.ImageFont.truetype("DejaVuSans.ttf", 12)
    im = PIL.Image.new(mode="1", size=bbox, color=1) # black-and-white
    draw = PIL.ImageDraw.Draw(im)
    print(draw.multiline_textsize(text))
    draw.multiline_text((0,0), text)
    return im

def h_merge(images):
    # Alignment is top-aligned
    combined_width = sum(image.size[0] for image in images)
    max_height = max(image.size[1] for image in images)
    im = PIL.Image.new(mode="1", size=(combined_width, max_height), color=1) #B+W
    width = 0
    for source_image in images:
        im.paste(source_image,(width, 0))
        width += source_image.size[0]
    return im

def v_merge(images):
    # Alignment is left-aligned
    max_width = max(image.size[0] for image in images)
    combined_height = sum(image.size[1] for image in images)
    im = PIL.Image.new(mode="1", size=(max_width, combined_height), color=1) #B+W
    height = 0
    for source_image in images:
        im.paste(source_image,(0, height))
        height += source_image.size[1]
    return im

if __name__ == "__main__":
    # defaults settings
    qr_version = 10
    error_correction = qrcode.constants.ERROR_CORRECT_M # default, 25%
    scale = 8
    dpi = 300
    page_w_points, page_h_points = 500,600
    MODE = qrcode.util.MODE_8BIT_BYTE # not settable
    restore_file = None
    use_base64 = False
    use_compression = True

    # parse command-line arguments
    args = sys.argv[1:]
    pargs = []
    while len(args) > 0:
        arg, args = args[0], args[1:]
        if arg in ["-h", "--help"]:
            show_help(status=0)
        elif arg == "--base64":
            use_base64 = True
        elif arg == "--compress":
            use_compression = True
        elif arg == "--dpi":
            if len(args) < 1:
                show_help()
            dpi, args = int(args[0]), args[1:]
        elif arg == "--error-correction":
            if len(args) < 1:
                show_help()
            error_correction, args = {"L":L, "M": M, "Q": Q, "H": H}[args[0].upper()], args[1:]
        elif arg == "--filename":
            if len(args) < 1:
                show_help()
            restore_file, args = args[0], args[1:]
            assert len(restore_file) > 0 and not restore_file.startswith("-")
        elif arg == "--no-compress":
            use_compression = False
        elif arg == "--page":
            if len(args) < 2:
                show_help()
            page_w_points, page_h_points, args = float(args[0]), float(args[1]), args[2:]
        elif arg == "--qr-version":
            if len(args) < 1:
                show_help()
            qr_version, args = int(args[0]), args[1:]
        elif arg == "--scale":
            if len(args) == 0:
                show_help()
            scale, args = int(args[0]), args[1:]
        elif arg in ["-v", "--verbose"]:
            logging.basicConfig(level=logging.INFO)
        elif arg == "-":
            pargs.append(arg)
        elif arg == "--":
            # Stop parsing arguments
            pargs, args = pargs + args, []
        elif arg.startswith("-"):
            show_help()
        else:
            pargs.append(arg)
    if len(pargs) != 1:
        show_help()
    file_path, = pargs

    if file_path == "-":
        output_path = "{restore_file or 'stdin'}.qr.pdf"
    else:
        if restore_file is None and len(file_path) <= 32:
            restore_file = file_path
        output_path = file_path+".qr.pdf"
    if not sys.stdout.isatty():
        output_path = sys.stdout.buffer # pipe to stdout instead
    if restore_file is None:
        restore_file = "file"

    nice_cmd = ' '.join([x for x in ["qr-backup", "--qr-version", str(qr_version), "--dpi", str(dpi), "--scale", str(scale), "--error-correction", "LMQH"[error_correction], "--page", str(page_w_points), str(page_h_points), '--compress' if use_compression else '--no-compress', '--base64' if use_base64 else None, "--filename", restore_file] if x is not None])
    backup_date = datetime.date.today().strftime("%Y-%m-%d")

    # open the file (or stdin, if "-" is passed as the file)
    if file_path == "-":
        f = sys.stdin.buffer
    else:
        f = open(file_path, "rb")

    # read the entire file into memory
    try:
        content = f.read()
    finally:
        f.close()
    sha256sum = hashlib.sha256(content).hexdigest()
    original_len = len(content)
    logging.info(f"read file {restore_file} (sha {sha256sum}, {original_len/1000}KB)")

    # (Gzip) Compression
    if use_compression:
        content = gzip.compress(content)

    # Base-64 encoding
    NEWLINE_ESCAPE = b"\b"
    if NEWLINE_ESCAPE in content or b"\0" in content:
        use_base64 = True

    if use_base64:
        # Deal with NEWLINE_ESCAPE and \0
        content = base64.b64encode(content)
    else:
        # Escape newlines so zbar* --raw (newline-separated) is useful
        content = content.replace(b"\n",NEWLINE_ESCAPE) # for easier reading back in, when QRs are printed newline-separated

    # Generate QR codes
    code_digits, qrs = qr_codes(content, error_correction=error_correction, version=qr_version, scale=scale)

    # Instructions depend on the command line option
    HOWTO = f'This is a {backup_date} paper backup of a computer file called: {restore_file}'
    HOWTO += '\nTo restore this file from the command line in Linux:'
    HOWTO += f'\n  Step 1 (webcam option): zbarcam --raw | tee -a /tmp/qrs | cut -c1-{code_digits} # Scan each code at least once in any order'
    HOWTO += f'\n  Step 1 (scanner option): zbarimg -q --raw *.png >>/tmp/qrs'
    HOWTO += f'\n  Step 2 (restore): sort -u /tmp/qrs | cut -c{code_digits+1}-'
    if use_base64:
        HOWTO += ' | base64 -d'
    else:
        HOWTO += ' | tr -d "\\n" | tr "\\b" "\\n"' # Update if NEWLINE_ESCAPE is updated.
    if use_compression:
        HOWTO += ' | gunzip'
    HOWTO += f' >{restore_file}'
    HOWTO += f'\nStep 3 (verify): sha256sum {restore_file} # {sha256sum}'
    HOWTO += f'\nThis backup was generated with: {nice_cmd}'

    # Calculate QR padding produced by qrcode module
    example_qr = qrs[0].make_image().copy()
    qr_bbox = PIL.ImageOps.invert(example_qr.copy().convert("L")).getbbox()
    qr_lpad, qr_tpad, qr_rpad, qr_bpad = qr_bbox[0], qr_bbox[1], example_qr.size[0]-qr_bbox[2], example_qr.size[1]-qr_bbox[3]
    qr_hpad, qr_vpad = qr_lpad + qr_rpad, qr_tpad + qr_bpad

    # Output QR codes with labels to Pillow Image objects
    labeled = []
    for i, qr in enumerate(qrs):
        img = qr.make_image()
        label = f"code {i+1:0>{code_digits}}/{len(qrs):0>{code_digits}} {restore_file}"
        labeled.append(add_label(img, label))
        labeled[0].save("test.png")
    logging.info(f"{len(qrs)} qr codes (at version {qr_version}) total")

    # Figure out page layout now that we know the size and number of QR codes. Output to the user.
    qr_w_pixel, qr_h_pixel = labeled[0].size
    logging.info(f"QR code (including label) is: {qr_w_pixel}x{qr_w_pixel}px")

    page_w_pixel, page_h_pixel = math.floor(page_w_points/72.0*dpi), math.floor(page_h_points/72.0*dpi) # 1 "dot" = 1 pixel. !!important note, DPI is not used yet, which is probably some config bug in Pillow
    logging.info(f"Page is: {page_w_pixel}x{page_h_pixel}px")

    howto_label = generate_label(HOWTO, page_w_pixel - qr_hpad)
    howto_height = howto_label.size[1]
    
    page_w_qr, page_h_qr = math.floor((page_w_pixel-2) // qr_w_pixel), math.floor((page_h_pixel-2-howto_height) // qr_h_pixel)
    qr_per_page = page_w_qr * page_h_qr
    if qr_per_page == 0:
        logging.error("Not even 1 QR fits on the given page. Forcing output anyway...")
        page_w_qr, page_h_qr, qr_per_page = 1,1,1
    num_pages = math.ceil(len(qrs)/qr_per_page)
    logging.info(f"{page_w_qr} x {page_h_qr} qr codes (at version {qr_version}) per page. {num_pages} pages total")

    density = original_len / num_pages
    logging.info(f"{len(content)} bytes in {num_pages} ({density/1000:.2f}KB/page)")

    # Combine rows
    rows = []
    for row_start in range(0, len(qrs), page_w_qr):
        row_qrs = labeled[row_start:row_start+page_w_qr]
        rows.append(h_merge(row_qrs))

    # Use imagemagick to make one png file per page-side
    pages = []
    for page_num, page_start in enumerate(range(0, len(rows), page_h_qr)):
        page = PIL.Image.new(mode="1", size=(page_w_pixel, page_h_pixel), color=1)
        page_rows = rows[page_start:page_start+page_h_qr]
        page_qrs = v_merge(page_rows)
    
        page_complete = add_label(page_qrs, HOWTO, side="top", max_fontsize=24)
        page_draw = PIL.ImageDraw.Draw(page)
        page_draw.rectangle(((0,0), (page_w_pixel-1, page_h_pixel-1)), outline=0, fill=1, width=1) # Rectangle for debugging print cutoff, and to look nice.
        page_num = generate_label("page {}/{}".format(page_num+1, num_pages), max_width=example_qr.size[0]/2)
        page.paste(page_num, (page.size[0]-page_num.size[0]-1-qr_rpad, page.size[1]-page_num.size[1]-11))
        page.paste(page_complete, (1,1))
        pages.append(page)

    pages[0].save(output_path, format="pdf", save_all=True, append_images=pages[1:], resolution=dpi, producer="qr-backup", title=f"qr-backup paper backup of {restore_file} with sha256 {sha256sum} and length {original_len}")
    #pages[0].save("example.png")
