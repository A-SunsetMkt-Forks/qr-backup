#!/usr/bin/env python3
"""
Takes a binary file, and outputs a "paper backup": a printable pdf full of QR codes. 

Following the directions in the pdf, the QR codes can be re-scanned or photographed using a webcam to restore the original file.

Requirements to make the PDF: python 'qrcode' library, imagemagick, img2pdf, reedsolo
Requirements to restore from the PDF, no erasure coding:   zbar, imagemagick (temporary)
                                      with erasure coding: zbar, imagemagick (temporary), qrcode, reedsolo
"""
import PIL, PIL.Image, PIL.ImageDraw, PIL.ImageFont, PIL.ImageOps
import english_wordlist
import atexit, base64, copy, datetime, gzip, hashlib, io, logging, math, os, random, subprocess, sys, tempfile, textwrap
import reedsolo
import qrcode
assert sys.version_info >= (3,6), "Python 3.6 is required. Submit a patch removing f-strings to fix it, sucka!"

HELP='''Usage: qr-codes.py [OPTIONS] FILE
               qr-codes.py --restore [OPTIONS]
               qr-codes.py --restore [OPTIONS] IMAGE [IMAGE ...]
Convert a binary file to a paper .pdf backup of QR codes. With '--restore',
read the QR codes in the paper backup using a webcam or scanner, to re-create
the original file.

Restore directions are included in the PDF, and do not require qr-backup. Make
sure to test that you can actually read the QR size you select.

Backup options:
    --dpi DPI
        Sets the print resolution of your printer.
        Default: 600
    --compress, --no-compress
        This gives a more compact backup, but partial recovery is impossible.
        Default: compressed
    --encrypt generate, --encrypt PASSPHRASE
        Password-protect the backup. If the passphrase is 'generate', a
        passphrase is automatically generated for you, which you would need
        to store securely or you will be unable to unlock the data.
        Default: disabled
    --encrypt-print-passphrase, --no-encrypt-print-passphrase
        Print the passphrase on a sheet by itself.
        Default: print if generated by qr-code, don't print if passed in
    --erasure-coding, --no-erasure-coding
        This allows restoring if some QR codes are lost. Restore with lost
        codes is only possible using qr-backup
        Default: enabled
    --error-correction CORRECTION
        Sets the error correction level. Options are L (7%), M (15%), Q (25%),
        and H (30%).
        Default: M (15%)
    --filename FILENAME
        Set the restored filename. Max 32 chars.
        Default: same as <FILE>
    --instructions page|cover|both|none
        Sets how frequently the instructions are printed. If 'cover' or 'both'
        is selected, more verbose instructions will be printed on the cover
        page. 
        Default: page
    --note TEXT
        Add a special note to the printout instructions. Can be anything.
        Default: no note
    --num-copies NUMBER
        Print multiple copies of each QR code for redundancy.
        Default: 1
    --output FILENAME, -o FILENAME
        Set the output pdf path (redirecting stdout also works).
        Default: <FILE>.qr.pdf
    --page WIDTH_POINTS HEIGHT_POINTS
        Sets the usable size of the paper on your printer. This should NOT be
        8.5 x 11 -- make sure to include margins.
        Default: 500px x 600px
    --qr-version VERSION
        Uses QR codes, version VERSION. Versions range from 1-40. The bigger
        the version, the harder to scan but the more data per code.
        Default: 10
    --scale SCALE
        Scale QR codes so that each small square in the QR code is 
        SCALE x SCALE pixels.
        Default: 5px
    --shuffle, --no-shuffle
        Spread QR codes across pages. This can help prevent data loss.
        Default: yes if erasure coding is enabled (default), no otherwise

Restore options:
    --code-count-erasure COUNT, -c COUNT
        Specify the number of erasure QR codes.
        Default: automatic
    --code-count-normal COUNT, -c COUNT
        Specify the number of normal QR codes.
        Default: automatic
    --compress, --no-compress
        Force decompression (on/off).
        Default: automatic
    --encrypt PASSPHRASE, --no-encrypt
        Force decryption (on/off) and give the passphrase if decrypting.
        Default: automatic
    --image-restore
        Force image-based (scanner) restore.
        Default: automatic
    --display, --no-display
        For webcam scanning, (display/don't display) a webcam preview.
        Default: display
    --output FILENAME, -o
        Set the restore file path.
        Default: stdout
    --sha256 SHA256
        Include a sha256sum to check the file.
        Default: no check, prints checksum to stderr
    --webcam-restore
        Force webcam-based restore.
        Default: automatic

Options for both:
    --verbose, -v
        Print more detailed information during run
'''
assert all(len(line)<=80 for line in HELP.split("\n"))

COVER = """
DO NOT THROW OUT

This backup was generated using qr-backup, a program to back up computer files to physical paper. The person who made the backup went through a lot of
work to make and print this document, and will probably be mad at you if you throw it out. They will also end up with big problems if/when their important
file goes missing.

To learn more about qr-backup, visit https://github.com/za3k/qr-backup.

== Information about this backup ==

File: {restore_file}
Backup created on: {backup_date}
Size (bytes): {original_len}
SHA256: {sha256sum}
Command used: {nice_cmd}
{notes}
== How to restore ==

You will need access to a Linux computer and a command line. You will also need to install 'zbar' and imagemagick.

To restore using a webcam and the Linux command line:
  Step 1 (scan): zbarcam --raw | tee /tmp/qrs | cut -c1-{code_end}
    Scan each code at least once in any order'
  Step 2 (restore): {howto_restore_cmd} >{restore_file}'
  Step 3 (verify): sha256sum {restore_file} # Check against SHA256 above

To restore using a webcam and qr-backup:
  Step 1: qr-backup --restore

To restore using a scanner and the Linux command line:
  Step 1 (scan): Scan the images with your scanner. Save them as any image format, it doesn't matter.
  Step 2 (scan): zbarimg -q --raw *.png >/tmp/qrs
  Step 3 (restore): {howto_restore_cmd} >{restore_file}
  Step 4 (verify): sha256sum {restore_file} # Check against SHA256 above

To restore using a scanner and qr-backup:
  qr-backup --restore IMAGE1 IMAGE2 ...

== Dear future archivists ==

(You can probably ignore this section)

If you don't have access to the Linux command line, and you don't have access to qr-backup, here is an explanation of how the backup is structured.
You will need a computing device and a great deal of technical expertise to restore this way.

- First, each QR code is scanned. QR is a 2D "bar"code in common use.
  QR is too complex to explain here. It is designed by Denso Wave. Each QR code holds 7 to 2953 bytes as binary data (depends on the settings)
  The error correction level (L/M/Q/H) and version (size, 1-40) are given in "command" under the backup information above.
  Many common devices can scan QR codes, such as 2012-2020 "smart" cell phones.
- Each QR code is labeled--the label matches the data written under the QR code.
  This data only used to label which code is which. It is removed.
- The non-label contents of each QR-code are base64.
  Base64 holds 6 bits per character. The full character set is:
    ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
    = is used as padding so the final size is a multiple of 24 bits
  base64 is detailed in RFC 4648 (base16, base32, and base64). The string "ZXhhbXBsZQ==" is decoded as "example".
  The command-line tool base64 or many commonly-available internet tools provide this function.
  It is reasonable to program a tool to decode base64 yourself. Convert from base-64 given above to base-256 (bytes).
- The decoded base64 from every QR code is appended together in order.
- If the --encrypt option is given, the file must be decrypted.
  The details of GPG decryption are too long to include here, but the algorithm used was AES256.
- If the --compress option is given, the file must be gzip-decompressed.
  The details of gzip are too long to include here, see RFC 1951 (DEFLATE).
  Naming a file "XXX.gz" allows it to be decompressed on Windows, Mac/Apple, BSD, Linux, and Unix. 
- The file is now assembled.
- The file is checksummed using sha256, which verifies the file is perfectly restored.
  The checksum is detailed in United States NIST standard FIPS PUB 180-2 (SHA2)
  Many standard tools like sha256 perform this checksum.
"""

L = qrcode.constants.ERROR_CORRECT_L
M = qrcode.constants.ERROR_CORRECT_M # default, 25%
Q = qrcode.constants.ERROR_CORRECT_Q
H = qrcode.constants.ERROR_CORRECT_H
QR_MODE = qrcode.util.MODE_8BIT_BYTE # not settable. and no, base64 encoded data doesn't bit in alphanumeric (there are only 44 chars)

# Greyscale is required to work around https://github.com/python-pillow/Pillow/issues/6149
IMAGE_MODE="L"
WHITE=255
BLACK=0

CONVERSION_DENSITY = 600 # pdf to pixel-based format conversion hack
ZBAR_WARNING_THRESHOLD = 0.9 # do we want to accept that zbar just can't scan the perfect original?

VERSIONS_BITS = {
    # Binary bits for each version size, 1-40
    # Source: qrcode.com (DENSO WAVE)
    # Order is L,M,Q,H on right
    1: [152,128,104,72],
    2: [272,224,176,128],
    3: [440,352,272,208],
    4: [640,512,384,288],
    5: [864,688,496,368],
    6: [1088,864,608,480],
    7: [1248,992,704,528],
    8: [1552,1232,880,688],
    9: [1856,1456,1056,800],
    10: [2192,1728,1232,976],
    11: [2592,2032,1440,1120],
    12: [2960,2320,1648,1264],
    13: [3424,2672,1952,1440],
    14: [3688,2920,2088,1576],
    15: [4184,3320,2360,1784],
    16: [4712,3624,2600,2024],
    17: [5176,4056,2936,2264],
    18: [5768,4504,3176,2504],
    19: [6360,5016,3560,2728],
    20: [6888,5352,3880,3080],
    21: [7456,5712,4096,3248],
    22: [8048,6256,4544,3536],
    23: [8752,6880,4912,3712],
    24: [9392,7312,5312,4112],
    25: [10208,8000,5744,4304],
    26: [10960,8496,6032,4768],
    27: [11744,9024,6464,5024],
    28: [12248,9544,6968,5288],
    29: [13048,10136,7288,5608],
    30: [13880,10984,7880,5960],
    31: [14744,11640,8264,6344],
    32: [15640,12328,8920,6760],
    33: [16568,13048,9368,7208],
    34: [17528,13800,9848,7688],
    35: [18448,14496,10288,7888],
    36: [19472,15312,10832,8432],
    37: [20528,15936,11408,8768],
    38: [21616,16816,12016,9136],
    39: [22496,17728,12656,9776],
    40: [23648,18672,13328,10208],
}
def qr_size_chars(version, mode, quality):
    assert mode not in [qrcode.util.MODE_NUMBER, qrcode.util.MODE_KANJI]
    assert mode in [qrcode.util.MODE_ALPHA_NUM, qrcode.util.MODE_8BIT_BYTE]

    bits = VERSIONS_BITS[version][[L,M,Q,H].index(quality)]
    data_bits = bits-4-qrcode.util.length_in_bits(mode, version)
    if mode == qrcode.util.MODE_NUMBER: # Not verified
        return (data_bits//10)*3 + [0,0,0,0,1,1,1,2,2,2][data_bits%10]
    elif mode == qrcode.util.MODE_ALPHA_NUM: # Not verified
        return (data_bits//11)*2 + [0,0,0,0,0,0,1,1,1,1,1][data_bits%11]
    elif mode == qrcode.util.MODE_8BIT_BYTE: # Verified
        return math.floor(data_bits/8)
    elif mode == qrcode.util.MODE_KANJI: # Not verified
        return math.floor(data_bits/13)

def qr_grid_size(version):
    return version*4+17

def program_present(program):
    """Return True or False depending on whether the program is found in the environment"""
    return subprocess.call(["which", program], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0

def length_encode(data):
    length = len(data)
    prefix = str(length).encode('ascii') + b' ' # encode the length at the start
    return (prefix + data), (len(prefix), length)

def length_decode(data):
    length, rest = data.split(b' ', maxsplit=1)
    length = int(length)
    return rest[:length]

def shuffle(qrs):
    # Ideally we would feed in the page size, and figure out how to do this optimially.
    # But random is also pretty good, and this way we don't have to figure out the number
    # of QRs per page in advance
    # Note: if we do the optimal way, avoid problems with losing a page or one corner of
    # whole stack tearing off. Remember duplex.
    ret = copy.copy(qrs)
    det = random.Random(1)
    det.shuffle(ret)
    return ret

def generate_chunks(data, chunk_size_base64, allowable_loss_fraction=0):
    """
    Return a bunch of chunks to put in QRs.
    The returned values must not contain "\n" due to the use of zbarimg/zbarcam, so we base-64 encode everything at the QR level
    Note that the data may be zero-padded on the right during this process.

    data: data to return, as Bytes
    chunk_size_base64: maximum size of each chunk, in QR-safe characters
    """
    
    # Figure out the number of digits in the number of QR codes (which is circular)
    binary_parity_chunks = []
    num_qrs, total_chunks = 0, 0
    for chunk_digits in range(1, 10):
        prefix_normal_format = "N{:0>" + str(chunk_digits) + "}/{:0>" + str(chunk_digits)+"} "
        prefix_parity_format = "P{:0>" + str(chunk_digits) + "}/{:0>" + str(chunk_digits)+"} "
        payload_size_base64 = chunk_size_base64 - len(prefix_normal_format.format(0,0))
        payload_size_bytes = math.floor(payload_size_base64 / 4) * 3 # groups of 4 base-64 digits encode 3 bytes each
        num_qrs = math.ceil(len(data) / payload_size_bytes)
        if num_qrs > 10**chunk_digits-1:
            continue
        num_parity_chunks = erasure_count(num_qrs, allowable_loss_fraction)
        if num_parity_chunks > 10**chunk_digits-1:
            continue
        break
    assert math.ceil(len(data)/payload_size_bytes) == num_qrs <= 10**chunk_digits-1

    # Pad to even chunk length
    padding_size = -len(data) % payload_size_bytes
    data += b'\0'*padding_size
    assert len(data)%payload_size_bytes == 0

    # Split into chunks
    binary_chunks = []
    for start in range(0, len(data), payload_size_bytes):
        chunk_data_bytes = data[start:start+payload_size_bytes]
        binary_chunks.append(chunk_data_bytes)
    assert all(len(chunk_data_bytes) == payload_size_bytes for chunk_data_bytes in binary_chunks)
    assert len(binary_chunks) == num_qrs

    # Generate erasure codes
    if num_parity_chunks > 0:
        binary_parity_chunks = generate_erasure(binary_chunks, allowable_loss_fraction)
        assert num_parity_chunks == len(binary_parity_chunks)

    # Output the chunks
    ascii_chunks = []
    for i, chunk_data_bytes in enumerate(binary_chunks):
        prefix = prefix_normal_format.format(i+1, num_qrs).encode('ascii')
        chunk_data_base64 = base64.b64encode(chunk_data_bytes)
        assert len(chunk_data_base64) <= payload_size_base64
        chunk_content = prefix+chunk_data_base64
        assert len(chunk_content) <= chunk_size_base64
        label = prefix[:-1].decode('ascii')
        ascii_chunks.append((chunk_content, label))
    for i, chunk_data_bytes in enumerate(binary_parity_chunks):
        prefix = prefix_parity_format.format(i+1, num_parity_chunks).encode('ascii')
        chunk_data_base64 = base64.b64encode(chunk_data_bytes)
        assert len(chunk_data_base64) <= payload_size_base64
        chunk_content = prefix+chunk_data_base64
        assert len(chunk_content) <= chunk_size_base64
        label = prefix[:-1].decode('ascii')
        ascii_chunks.append((chunk_content, label))
    assert len(ascii_chunks) == num_qrs + num_parity_chunks
    assert all(len(chunk) == chunk_size_base64 for chunk, label in ascii_chunks)

    return chunk_digits, ascii_chunks

DEFAULT_ALLOWABLE_LOSS = 0.3
ERASURE_SPLIT = 177 # with allowable_loss_fraction=0.3, hits ERASURE_LIMIT of 254. TODO: Have it depend on allowable_loss_fraction instead of assuming DEFAULT_ALLOWABLE_LOSS?
ERASURE_LIMIT = 254
def erasure_count(num_normal_pieces, allowable_loss_fraction):
    if allowable_loss_fraction == 0:
        return 0

    simple_erasures = lambda n: math.ceil(n * allowable_loss_fraction / (1-allowable_loss_fraction))
    assert simple_erasures(0) == 0
    num_erasures = simple_erasures(num_normal_pieces)
    if num_erasures + num_normal_pieces <= ERASURE_LIMIT:
        return num_erasures

    num_erasures_max = simple_erasures(ERASURE_SPLIT)
    last_piece_size = num_normal_pieces % ERASURE_SPLIT
    num_erasures_last = simple_erasures(last_piece_size)
    return num_erasures_max * (num_normal_pieces//ERASURE_SPLIT) + num_erasures_last

def generate_erasure(binary_chunks, allowable_loss_fraction, self_test=True):
    """
    given data chunks (as equal-length bytes objects), generate parity chunks for k-of-n restore.
    k = len(binary_chunks)
    n = len(binary_chunks)+erasure_count
    """
    num_erasures = erasure_count(len(binary_chunks), allowable_loss_fraction)
    chunk_size = len(binary_chunks[0])
    assert all(len(chunk) == chunk_size for chunk in binary_chunks)
    num_total_chunks = len(binary_chunks) + num_erasures

    if num_total_chunks > ERASURE_LIMIT:
        # Chunk manually, rather than using reedsolo's default chunking.
        # Reedsolo has fencepost errors
        # Reedsolo outputs nnnppnnnpp. We want nnnnnnpppp. (n=normal, p=parity)
        # Ideally this would be an interleaved reedsolomon code, but it was too complicated for me to figure out, so instead we just do a simple chunked version, then shuffle and hope.
        assert allowable_loss_fraction == DEFAULT_ALLOWABLE_LOSS
        erasure_codes = []
        for start in range(0, len(binary_chunks), ERASURE_SPLIT):
            new_erasure = generate_erasure(binary_chunks[start:start+ERASURE_SPLIT], allowable_loss_fraction, self_test=False)
            erasure_codes.extend(new_erasure)
        symbols = binary_chunks + erasure_codes
    else:
        assert num_total_chunks <= ERASURE_LIMIT, "Support for erasure codes on >20KB files not yet implemented"

        codec = reedsolo.RSCodec(num_erasures)
        groups = [bytes(x) for x in zip(*binary_chunks)]
        assert len(binary_chunks) == len(groups[0])
        assert chunk_size == len(groups)
        symbols = [bytes(a) for a in zip(*(codec.encode(group) for group in groups))]
        assert len(symbols) != 0
        assert all(len(symbol)==chunk_size for symbol in symbols)
        assert all(binary_chunks[i] == symbols[i] for i in range(0,len(binary_chunks)))
        assert len(symbols) == num_total_chunks

        erasure_codes = symbols[-num_erasures:]
    assert len(erasure_codes) == num_erasures

    if self_test:
        # Self-test of restore
        logging.info("generate_erasure: perform self-test")
        num_erased = num_erasures if (num_total_chunks <= ERASURE_LIMIT) else num_erasures//2
        symbols = copy.copy(symbols)

        for i in random.Random(1).sample(range(len(symbols)), num_erased):
            symbols[i] = None
        self_check = restore_erasure(symbols[:-num_erasures], symbols[-num_erasures:], allowable_loss_fraction)
        data = b''.join(binary_chunks)
        assert self_check == data, "Self-check failed in generate_erasure"
        logging.info("generate_erasure: deleted first few symbols, restore works fine")

    return erasure_codes

def restore_erasure(normal_codes, erasure_codes, allowable_loss_fraction):
    """Restores erasure-coded content. Note that this will still be padded after"""
    symbols = normal_codes + erasure_codes
    assert any(symbol is not None for symbol in symbols)

    chunk_size = max(len(symbol) for symbol in symbols if symbol is not None)
    missing_symbols = [i for i,symbol in enumerate(symbols) if symbol is None]
    for i in missing_symbols:
        symbols[i] = b' '*chunk_size # Doesn't really matter what we set this to as long as it's the right length.
    assert all(isinstance(symbol, bytes) for symbol in symbols)
    assert all(len(symbol)==chunk_size for symbol in symbols)

    num_erasures = erasure_count(len(normal_codes), allowable_loss_fraction)
    assert len(erasure_codes) == num_erasures, "{} != {}".format(len(erasure_codes), num_erasures)

    if len(symbols) > ERASURE_LIMIT:
        assert allowable_loss_fraction == DEFAULT_ALLOWABLE_LOSS
        # Decode multiple blocks
        num_erasures_per_split = erasure_count(ERASURE_SPLIT, allowable_loss_fraction)
        decoded = b''
        fixed = []
        for block_num in range(0, math.ceil(len(normal_codes)/ERASURE_SPLIT)):
            local_normal = normal_codes[block_num*ERASURE_SPLIT:(block_num+1)*ERASURE_SPLIT]
            local_erasure = erasure_codes[block_num*num_erasures_per_split:(block_num+1)*num_erasures_per_split]
            restored_binary = restore_erasure(local_normal, local_erasure, allowable_loss_fraction)
            fixed.append(restored_binary)
        decoded = b''.join(fixed)
        assert len(decoded) == len(normal_codes)*chunk_size
        return decoded
    else:
        # Decode single block
        codec = reedsolo.RSCodec(num_erasures)
        broken_strings = list(zip(*symbols))
        fixed_strings = [codec.decode(x, erase_pos=missing_symbols, only_erasures=True)[0] for x in broken_strings]
        simple_restore = b''.join(bytes(x) for x in zip(*fixed_strings))
        assert len(simple_restore) == len(normal_codes)*chunk_size
        return simple_restore

class QR():
    def __init__(self, qr, label):
        self.qr = qr
        self.label = label

def qr_codes(data, error_correction, version, scale, allowable_loss_fraction=0):
    naive_chunk_size = qr_size_chars(version, QR_MODE, error_correction)
    chunk_digits, chunks = generate_chunks(data, naive_chunk_size, allowable_loss_fraction)
    
    qrs = []
    for data, label in chunks:
        qr = qrcode.QRCode(
            version=version,
            error_correction=error_correction,
            box_size=scale,
            border=0,
        )
        assert len(data) <= naive_chunk_size
        qr.add_data(qrcode.util.QRData(data, mode=QR_MODE), optimize=0)
        qr.make(fit=False)
        qrs.append(QR(qr, label))
    qr_pad = scale*4

    return chunk_digits, qr_pad, qrs

def generate_passphrase():
    return ' '.join(random.choices(english_wordlist.words, k=8))

# I took a look at the python 'gnupg' library... it doesn't support bytes, and it isn't really designed to do symmetric encryption/decryption either.
def encrypt(content_bytes, passphrase, armor=False, cipher="AES256"):
    # I chose to hardcode an encryption cipher, to make documenting the restore easier. This does make it harder to futureproof, and some people may distrust AES already.
    result = subprocess.run(["gpg", "--symmetric", "--no-symkey-cache", "--passphrase", passphrase, "--batch", "--cipher-algo"] + (["--armor"] if armor else []), capture_output=True, input=content_bytes)
    assert result.returncode == 0
    return result.stdout

def decrypt(content_bytes, passphrase):
    result = subprocess.run(["gpg", "--decrypt", "--no-symkey-cache", "--passphrase", passphrase, "--batch"], capture_output=True, input=content_bytes)
    assert result.returncode == 0
    return result.stdout

def show_help(error=None):
    if error:
        print(HELP, file=sys.stderr)
        print(file=sys.stderr)
        print("ERROR: {}".format(error), file=sys.stderr)
        sys.exit(1)
    else:
        print(HELP)
        sys.exit(0)

def add_label(image, text, side="bottom", max_fontsize=24, max_width=None, label=None):
    """
    Add a label. The fontsize is max_fontsize if possible, otherwise it's shrunk down.
    The label is aligned to the bounding box of the image (lines up with margins).
    """
    # Figure out the size and position of the original image
    bbox = PIL.ImageOps.invert(image.copy().convert("L")).getbbox()
    if bbox is None:
        left, upper, right, lower = 0,0,0,0
        if max_width is None:
            max_width = image.size[0]
    elif max_width is None:
        left, upper, right, lower = bbox
        max_width = right-left
    else:
        left, upper, right, lower = bbox
        right, max_width = max(right, max_width), max_width-left

    # Generate a label that fits. The fontsize will be reduced if needed. No word wrap is performed.
    if label is None:
        label = generate_label(text, max_width=max_width, max_fontsize=max_fontsize)
    else:
        assert label.size[0] <= max_width, "Premade label is too wide"
    label_bbox = PIL.ImageOps.invert(image.copy().convert("L")).getbbox()

    # Layout
    width, combined_height = max(image.size[0], left+label.size[0]), image.size[1] + label.size[1]
    labeled = PIL.Image.new(mode=IMAGE_MODE, size=(width, combined_height), color=WHITE) #B+W
    if side == "bottom":
        labeled.paste(image, (0,0))
        labeled.paste(label, (left,image.size[1]))
    elif side == "top":
        labeled.paste(label, (left,0))
        labeled.paste(image, (0,label.size[1]))
    else:
        assert False, "Unknown side for label: {}".format(side)
    return labeled

def generate_label(text, max_width, max_fontsize=24, min_fontsize=4):
    # to do, maybe some fancy word wrap
    test_im = PIL.Image.new(mode=IMAGE_MODE, size=(1,1), color=WHITE)
    test_draw = PIL.ImageDraw.Draw(test_im)

    for fontsize in range(max_fontsize, min_fontsize-1, -1):
        font = PIL.ImageFont.truetype("DejaVuSans.ttf", fontsize)
        _, _, width, height = test_draw.multiline_textbbox((0, 0), text, font=font)
        height += 4
        if width <= max_width:
            im = PIL.Image.new(mode=IMAGE_MODE, size=(width, height), color=WHITE) # black-and-white
            draw = PIL.ImageDraw.Draw(im)
            draw.multiline_text((0,-2), text, font=font) # Eurgh, hardcoding an offset.
            return im
        else:
            logging.info("Reducing label size to {}".format(fontsize))
    #assert False
    logging.error("Label cannot fit in the requested width. Forcing output...")

    font = PIL.ImageFont.truetype("DejaVuSans.ttf", min_fontsize)
    width, height = test_draw.multiline_textsize(text, font=font)
    height += 4
    im = PIL.Image.new(mode=IMAGE_MODE, size=(max_width, height), color=WHITE) # black-and-white
    draw = PIL.ImageDraw.Draw(im)
    draw.multiline_text((0,-2), text, font=font) # Eurgh, hardcoding an offset.
    return im

def h_merge(images, padding=0):
    # Alignment is top-aligned
    combined_width = sum(image.size[0] for image in images) + padding*(len(images)-1)
    max_height = max(image.size[1] for image in images)
    im = PIL.Image.new(mode=IMAGE_MODE, size=(combined_width, max_height), color=WHITE) #B+W
    width = 0
    for source_image in images:
        im.paste(source_image,(width, 0))
        width += source_image.size[0] + padding
    return im

def v_merge(images, padding=0):
    # Alignment is left-aligned
    max_width = max(image.size[0] for image in images)
    combined_height = sum(image.size[1] for image in images) + padding*(len(images)-1)
    im = PIL.Image.new(mode=IMAGE_MODE, size=(max_width, combined_height), color=WHITE) #B+W
    height = 0
    for source_image in images:
        im.paste(source_image,(0, height))
        height += source_image.size[1] + padding
    return im

def main_backup(args):
    # default settings
    qr_version = 10
    error_correction = M # default, 25%
    scale = 5
    dpi = 300
    page_w_points, page_h_points = 500,600
    restore_file = None
    use_compression = True
    output_path = None
    GENERATE_DOCS = False # Manually generate example.png for the README when qr-backup changes
    add_page_instructions = True
    add_cover_instructions = False
    notes = []
    use_encryption = False
    encryption_passphrase = None
    print_passphrase = None
    use_erasure_coding = True
    use_shuffle = None
    num_copies = 1

    # parse arguments
    pargs = []
    while len(args) > 0:
        arg, args = args[0], args[1:]
        if arg in ["-h", "--help"]:
            show_help()
        elif arg == "--compress":
            use_compression = True
        elif arg == "--dpi":
            if len(args) < 1:
                show_help("--dpi requires one argument (an integer dots-per-inch)")
            dpi, args = int(args[0]), args[1:]
        elif arg == "--encrypt":
            # Note: --encrypt inherently makes the output nondeterministic. AES256 uses both a random IV and a salt.
            if len(args) < 1 or args[0].startswith("-"):
                show_help("--encrypt requires either 'generate' or a passphrase")
            use_encryption = True
            if args[0] == "generate":
                args = args[1:]
            else:
                encryption_passphrase, args = args[0], args[1:]
        elif arg == "--erasure-coding":
            use_erasure_coding = True
        elif arg == "--error-correction":
            if len(args) < 1:
                show_help("--error-correction requires one of: L M Q H")
            error_correction, args = {"L":L, "M": M, "Q": Q, "H": H}[args[0].upper()], args[1:]
        elif arg == "--filename":
            if len(args) < 1:
                show_help("--filename requires one argument")
            restore_file, args = args[0], args[1:]
            assert len(restore_file) > 0 and not restore_file.startswith("-")
        elif arg == "--generate-docs": # Development only. Don't document or use please.
            GENERATE_DOCS=True
        elif arg == "--instructions":
            if len(args) < 1:
                show_help("--instructions requires one argument")
            instruction_type, args = args[0], args[1:]
            if instruction_type == "page":
                add_page_instructions = True
                add_cover_instructions = False
            elif instruction_type == "cover":
                add_page_instructions = False
                add_cover_instructions = True
            elif instruction_type == "none":
                add_page_instructions = False
                add_cover_instructions = False
            elif instruction_type == "both":
                add_page_instructions = True
                add_cover_instructions = True
            else:
                show_help("--instructions requires one of: page cover both none")
        elif arg == "--no-compress":
            use_compression = False
        elif arg == "--no-erasure-coding":
            use_erasure_coding = False
        elif arg == "--no-shuffle":
            use_shuffle = False
        elif arg == "--note":
            if len(args) < 1:
                show_help("--note requires one argument")
            note, args = args[0], args[1:]
            for note_line in note.split("\n"):
                for line in textwrap.wrap(note_line, width=60, replace_whitespace=False):
                    notes.append(line)
        elif arg == "--num-copies":
            if len(args) < 1:
                show_help("--num-copies requires one argument (integer >= 1)")
            num_copies, args = int(args[0]), args[1:]
            assert num_copies >= 1
        elif arg == "--page":
            if len(args) < 2:
                show_help("--page requires two arguments (decimal page width and height in inches)")
            page_w_points, page_h_points, args = float(args[0]), float(args[1]), args[2:]
        elif arg in ["-o", "--output"]:
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            output_path, args = args[0], args[1:]
        elif arg == "--qr-version":
            if len(args) < 1:
                show_help("--qr-version requires one argument (integer version between 2 and 40)")
            qr_version, args = int(args[0]), args[1:]
        elif arg == "--scale":
            if len(args) == 0:
                show_help("--scale requires one argument (integer scale in pixels)")
            scale, args = int(args[0]), args[1:]
        elif arg == "--shuffle":
            use_shuffle = True
        elif arg in ["-v", "--verbose"]:
            logging.basicConfig(level=logging.INFO)
        elif arg == "-":
            pargs.append(arg)
        elif arg == "--":
            # Stop parsing arguments
            pargs, args = pargs + args, []
        elif arg.startswith("-"):
            show_help()
        else:
            pargs.append(arg)
    if len(pargs) < 1:
        show_help("Please supply a filename to backup")
    elif len(pargs) > 1:
        show_help("Multiple filenames given. qr-backup can only back up one file at a time")
    input_path, = pargs

    use_stdout = (output_path is None) and not sys.stdout.isatty()
    use_stdin = (input_path == "-")
    if restore_file is None:
        input_filename = input_path.split("/")[-1]
        if not use_stdin and len(input_filename) <= 32:
            restore_file = input_filename
        else:
            restore_file = "file"
    if output_path is None:
        if use_stdin:
            output_path = f"{restore_file or 'stdin'}.qr.pdf"
        else:
            output_path = input_path+".qr.pdf"

    if use_shuffle is None:
        use_shuffle = use_erasure_coding

    if use_encryption and print_passphrase is None:
        print_passphrase = encryption_passphrase is None

    if use_encryption and not program_present("gpg"):
        show_help("gpg must be installed to use --encrypt. could not find gpg in the PATH")

    if use_erasure_coding:
        allowable_loss_fraction = DEFAULT_ALLOWABLE_LOSS
    else:
        allowable_loss_fraction = 0

    nice_cmd = ' '.join([x for x in ["qr-backup", "--qr-version", str(qr_version), "--dpi", str(dpi), "--scale", str(scale), "--error-correction", "LMQH"[error_correction], "--page", str(page_w_points), str(page_h_points), '--compress' if use_compression else '--no-compress', "--filename", '--encrypt ???' if use_encryption else None, "--use-erasure-coding" if use_erasure_coding else None, "--shuffle" if use_shuffle else "--no-shuffle", restore_file] if x is not None])
    if GENERATE_DOCS:
        backup_date = "2021-06-15"
    else:
        backup_date = datetime.date.today().strftime("%Y-%m-%d")
    logging.info("Original arguments were: {}".format(repr(args)))
    logging.info("Command arguments parsed. Equivalent command: {}".format(nice_cmd))

    # open the file (or stdin, if "-" is passed as the file)
    if use_stdin:
        f = sys.stdin.buffer
    else:
        f = open(input_path, "rb")

    # read the entire file into memory
    try:
        original_content = f.read()
    finally:
        f.close()

    sha256sum = hashlib.sha256(original_content).hexdigest()
    original_len = len(original_content)
    logging.info(f"read file {restore_file} (sha {sha256sum}, {original_len/1000}KB)")

    content = original_content

    # (Gzip) Compression
    if use_compression:
        content = gzip.compress(content, mtime=0)

    # Encryption
    if use_encryption:
        if encryption_passphrase is None:
            encryption_passphrase = generate_passphrase()
            print("Your secret encryption passphrase is: {}".format(encryption_passphrase), file=sys.stderr)
            print("Back this up somewhere secure or you will be unable to access your data", file=sys.stderr)
        content = encrypt(content, encryption_passphrase)

    # Add a length at the start
    content, range_ = length_encode(content)

    # Generate QR codes
    code_digits, qr_padding, qrs = qr_codes(content, error_correction=error_correction, version=qr_version, scale=scale, allowable_loss_fraction=allowable_loss_fraction)

    # Additional copies
    qrs = qrs * num_copies

    # Shuffle order of QR codes
    if use_shuffle:
        qrs = shuffle(qrs)

    # How to restore
    restore_cmd = f'sort -u | grep "^N" | cut -c{code_digits*2+4}- | base64 -d | tail -c +{range_[0]+1} | head -c {range_[1]}'
    if use_encryption:
        restore_cmd += ' | gpg --decrypt'
    if use_compression:
        restore_cmd += ' | gunzip'
    logging.info(f"Restore command is: {restore_cmd}")

    # Instructions depend on the command line options, and the content of the file
    HOWTO = f'This is a paper backup of a computer file called: {restore_file}'
    HOWTO += '\nTo restore this file using qr-backup:'
    HOWTO += f'\n  Step 1 (webcam): qr-backup --restore'
    HOWTO += f'\n  Step 1 (scanner): qr-backup --restore IMAGE1 IMAGE2 ...'
    HOWTO += '\nTo restore this file from the command line in Linux:'
    HOWTO += f'\n  Step 1 (webcam option): zbarcam --raw | tee /tmp/qrs | cut -c1-{code_digits+1} # Scan each code at least once in any order'
    HOWTO += f'\n  Step 1 (scanner option): zbarimg -q --raw *.png >/tmp/qrs'
    howto_restore_cmd = restore_cmd.replace("sort -u", "sort -u /tmp/qrs")
    HOWTO += f'\n  Step 2 (restore): {howto_restore_cmd} >{restore_file}'
    HOWTO += f'\n  Step 3 (verify): sha256sum {restore_file} # {sha256sum}, {original_len} bytes'
    HOWTO += f'\nThis backup was generated on {backup_date} with: {nice_cmd}'
    if len(notes) > 0:
        HOWTO += "\n" + "\n".join(["Additional note: " + note for note in notes])

    cover_txt = COVER.format(
        backup_date=backup_date,
        restore_file=restore_file,
        original_len=original_len,
        sha256sum=sha256sum,
        nice_cmd=nice_cmd,
        notes="\n".join(["Additional note: " + note for note in notes])+"\n" if len(notes) > 0 else "",
        code_end=code_digits+1,
        howto_restore_cmd=howto_restore_cmd,
    )

    # Calculate QR padding produced by qrcode module
    example_qr = qrs[0].qr.make_image().copy()
    qr_raw_w_pixel, qr_raw_h_pixel = example_qr.size

    # Output QR codes with labels to Pillow Image objects
    labeled = []
    for i, qr in enumerate(qrs):
        img = qr.qr.make_image()
        #label = f"code {i+1:0>{code_digits}}/{len(qrs):0>{code_digits}} {restore_file}"
        label = qr.label
        labeled.append(add_label(img, label))
    logging.info(f"{len(qrs)} qr codes (at version {qr_version}) total")

    # Figure out page layout now that we know the size and number of QR codes. Output to the user.
    qr_w_pixel, qr_h_pixel = labeled[0].size
    logging.info(f"QR code (including label) is: {qr_w_pixel}x{qr_w_pixel}px")

    page_w_pixel, page_h_pixel = math.floor(page_w_points/72.0*dpi), math.floor(page_h_points/72.0*dpi) # 1 "dot" = 1 pixel. !!important note, DPI is not used yet, which is probably some config bug in Pillow
    logging.info(f"Page is: {page_w_pixel}x{page_h_pixel}px")

    if add_page_instructions:
        howto_label = generate_label(HOWTO, page_w_pixel)
        howto_height = howto_label.size[1]
    else:
        howto_height = 0
    
    def max_units_with_padding(total_size, unit_size, padding_size):
        """Calculate the (whole) number of units of width UNIT_SIZE with required padding PADDING_SIZE fit in a layout of width TOTAL_SIZE"""
        # (qr_width*qrs) + (qr_padding*(qrs-1)) <= page_width
        # (qr_width+qr_padding)qrs - qr_padding <= page_width
        # qrs <= (page_width+qr_padding)/(qr_width+qr_padding)
        return int((total_size+padding_size)/(unit_size+padding_size))
    page_w_qr, page_h_qr = max_units_with_padding(page_w_pixel-2, qr_w_pixel, qr_padding), max_units_with_padding(page_h_pixel-2-howto_height, qr_h_pixel, qr_padding)
    qr_per_page = page_w_qr * page_h_qr
    if qr_per_page == 0:
        logging.error("Not even 1 QR fits on the given page. Forcing output anyway...")
        page_w_qr, page_h_qr, qr_per_page = 1,1,1
    num_qr_pages = math.ceil(len(qrs)/qr_per_page)
    logging.info(f"{page_w_qr} x {page_h_qr} qr codes (at version {qr_version}) per page. {num_qr_pages} pages total")

    uncompressed_density = len(content) / num_qr_pages
    compressed_density = original_len / num_qr_pages
    logging.info(f"{len(content)} compressed bytes in {num_qr_pages} page(s). {compressed_density/1000:.2f}KB/page including compression, {uncompressed_density/1000:.2f}KB/page without compression")
    theory_density_per_qr = original_len / len(qrs)
    theory_density = theory_density_per_qr * qr_per_page
    logging.info(f"{theory_density/1000:.2f}KB/page theory without compression)")

    qr_min_padded_height = max(qr_h_pixel, qr_raw_h_pixel+qr_padding)
    qr_v_padding = qr_min_padded_height - qr_h_pixel

    # Combine rows, adding horizontal padding
    rows = []
    for row_start in range(0, len(qrs), page_w_qr):
        row_qrs = labeled[row_start:row_start+page_w_qr]
        rows.append(h_merge(row_qrs, padding=qr_padding))

    # Use imagemagick to make one png file per page-side
    unnumbered_images = []
    if print_passphrase:
        passphrase_image = generate_label("File: {}\nDate: {}\nYour secret passphrase is: {}\n\nMake sure to hide this sheet somewhere secure, not with your backup!".format(restore_file, backup_date, encryption_passphrase), max_width=page_w_pixel-2)
        unnumbered_images.append((False, passphrase_image))
    if add_cover_instructions:
        cover_img = generate_label(cover_txt, page_w_pixel, max_fontsize=24, min_fontsize=24)
        assert cover_img.size[0] <= page_w_pixel - 2
        unnumbered_images.append((True, cover_img))
    for page_start in range(0, len(rows), page_h_qr):
        page_rows = rows[page_start:page_start+page_h_qr]
        page_qrs = v_merge(page_rows, padding=qr_v_padding)
        if add_page_instructions:
            page_complete = add_label(page_qrs, HOWTO, side="top", max_fontsize=24, max_width=page_w_pixel-2)
            unnumbered_images.append((True, page_complete))
        else:
            unnumbered_images.append((True, page_qrs))

    # Add a rectangle border and pad any small ones to full-page size
    unnumbered_pages = []
    for should_number, img in unnumbered_images:
        #assert img.size[0] <= page_w_pixel-2 and img.size[1] <= page_h_pixel-2
        if GENERATE_DOCS:
            page_h_pixel = img.size[1]+2 # minimize size for example.png
        page = PIL.Image.new(mode=IMAGE_MODE, size=(page_w_pixel, page_h_pixel), color=WHITE)
        page_draw = PIL.ImageDraw.Draw(page)
        page_draw.rectangle(((0,0), (page_w_pixel-1, page_h_pixel-1)), outline=BLACK, fill=WHITE, width=1) # Rectangle for debugging print cutoff, and to look nice.
        page.paste(img, (1,1)) # Main contents
        unnumbered_pages.append((should_number, page))

    # Add page numbers after. Currently page-numbering is perfectly reliable, but we're about to add more complicated layout options.
    pages = []
    num_pages = len(unnumbered_pages)
    for page_num, (should_number, page) in enumerate(unnumbered_pages):
        if should_number:
            page_num = generate_label("page {}/{}".format(page_num+1, num_pages), max_width=example_qr.size[0]/2)
            page.paste(page_num, (page.size[0]-page_num.size[0]-1, page.size[1]-page_num.size[1]-11)) # Page num in bottom-right
        pages.append(page)

    # PIL's pdf writer needs to mmap, so it can't accept sys.stdout directly
    tmp_pdf = io.BytesIO()
    pages[0].save(tmp_pdf, format="pdf", save_all=True, append_images=pages[1:], resolution=dpi, producer="qr-backup", title=f"qr-backup paper backup of {restore_file} with sha256 {sha256sum} and length {original_len}", creationDate=backup_date, modDate=backup_date)

    if use_stdout: 
        # Write PDF to stdout
        sys.stdout.buffer.write(tmp_pdf.getbuffer())
    else:
        # Write PDF to file
        with open(output_path, "wb") as f:
            f.write(tmp_pdf.getbuffer())

    # Self-test
    if use_encryption:
        test_restore_cmd = restore_cmd.replace("gpg --decrypt", "gpg --decrypt --no-symkey-cache --batch --passphrase '{}'".format(encryption_passphrase))
        logging.info("Restore command used in Linux CLI test: " + test_restore_cmd)
    else:
        test_restore_cmd = restore_cmd
    
    if not program_present("zbarimg"):
        logging.warning("Skipping digital restore verification, because zbarimg is not available.")
    elif not program_present("convert"):
        logging.warning("Skipping digital restore verification, because 'convert' is not available to work around a bug in zbarimg.")
    else:
        if use_stdout or use_stdin:
            logging.info("Performing linux CLI restore check...")
            # convert -density 300 is to work around errors in zbarcam. I offered an upstream patch as https://github.com/mchehab/zbar/pull/227
            linux_test_command = "convert -density {} pdf:- tif:- | zbarimg --raw -q -Sdisable -Sqrcode.enable - | {}".format(CONVERSION_DENSITY, test_restore_cmd)
            linux_test_rate_command = "convert -density {} pdf:- tif:- | zbarimg --raw -q -Sdisable -Sqrcode.enable - | wc -l".format(CONVERSION_DENSITY, test_restore_cmd)
            logging.info("Test command was: {}".format(linux_test_command))
            linux_test = subprocess.run(linux_test_command, shell=True, capture_output=True, input=tmp_pdf.getbuffer())
            linux_success = linux_test.returncode==0 and linux_test.stdout == original_content
            logging.info("Linux CLI exit code was: {}".format(linux_test.returncode))
            logging.info("Test command was: {}".format(linux_test_rate_command))
            linux_test_rate = subprocess.run(linux_test_rate_command, shell=True, capture_output=True, input=tmp_pdf.getbuffer())

            logging.info("Performing qr-backup restore check...")
            self_test_command = ["python3", sys.argv[0], "--restore", "--sha256", sha256sum, "-"]
            if use_encryption:
                self_test_command += ["--encrypt", encryption_passphrase]
            self_test = subprocess.run(self_test_command, capture_output=True, input=tmp_pdf.getbuffer())
            self_test_success = self_test.returncode==0
            logging.info("Self-test exit code was: {}".format(self_test.returncode))
        else:
            logging.info("Performing linux CLI restore check...")
            linux_test_command = "convert -density {} {} tif:- | zbarimg --raw -q -Sdisable -Sqrcode.enable - | {} | cmp {}".format(CONVERSION_DENSITY, output_path, test_restore_cmd, input_path)
            linux_test_rate_command = "convert -density {} {} tif:- | zbarimg --raw -q -Sdisable -Sqrcode.enable - | wc -l".format(CONVERSION_DENSITY, output_path, test_restore_cmd)
            logging.info("Test command was: {}".format(linux_test_command))
            linux_success = (subprocess.call(linux_test_command, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0)
            logging.info("Linux CLI xit code was: {}".format(linux_success))
            logging.info("Test command was: {}".format(linux_test_rate_command))
            linux_test_rate = subprocess.run(linux_test_rate_command, shell=True, capture_output=True, input=tmp_pdf.getbuffer())

            logging.info("Performing qr-backup restore check...")
            self_test_command = ["python3", sys.argv[0], "--restore", "--sha256", sha256sum, output_path]
            if use_encryption:
                self_test_command += ["--encrypt", encryption_passphrase]
            self_test_success = (subprocess.call(self_test_command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0)
            logging.info("Self-test exit code was: {}".format(self_test_success))

        qrs_read = int(linux_test_rate.stdout)
        qrs_fraction_read = qrs_read / len(qrs)
        logging.info("Read {}/{} qrs ({:.2f}%)".format(qrs_read, len(qrs), qrs_fraction_read*100))
        if not self_test_success:
            logging.error("!!Automatic digital restore verification FAILED (self-test). This indicates a bug in qr-backup. Please report this to the author at https://github.com/za3k/qr-backup/issues")
            #sys.exit(1)
        elif not linux_success:
            if qrs_fraction_read < ZBAR_WARNING_THRESHOLD:
                logging.info("!!Automatic digital restore verification FAILED (linux CLI). This indicates a bug in zbarimg, most likely. Please report this to the author at https://github.com/za3k/qr-backup/issues")
            else:
                logging.info("!!Automatic digital restore verification FAILED (linux CLI). This indicates a bug in qr-backup (more likely) or zbarimg. Please report this to the author at https://github.com/za3k/qr-backup/issues")
            #sys.exit(1)
        else:
            logging.info("Automatic digital restore verification succeeded.")

    if GENERATE_DOCS:
        pages[0].save("docs/example.png")
        with open("docs/USAGE.md", "w") as f:
            f.write("Output of `qr-backup --help`:\n")
            f.write("\n")
            f.write("```\n")
            f.write(HELP)
            f.write("\n")
            f.write("```\n")

def image_restore(image_paths):
    # Special note: image_paths can include "-", in which case zbarimg will magically do the right thing
    if not program_present("zbarimg"):
        logging.fatal("zbarimg not found. install 'zbar' to scan files.")
        sys.exit(2)

    # Special workaround hack while zbarimg doesn't deal with pdfs
    def _remove_file(t):
        try:
            os.unlink(t)
        except FileNotFoundError:
            pass
    if any(path.endswith(".pdf") for path in image_paths):
        temporary = []
        new_image_paths = []
        for image in image_paths:
            if image.endswith(".pdf"):
                handle, temp_tif = tempfile.mkstemp(suffix=".tif")
                temporary.append((handle, temp_tif))
                atexit.register(_remove_file, temp_tif)
                subprocess.run(["convert", "-density", str(CONVERSION_DENSITY), image, temp_tif], stderr=subprocess.DEVNULL)
                new_image_paths.append(temp_tif)
            else:
                new_image_paths.append(image)
        for line in image_restore(new_image_paths):
            yield line
        for handle, temp_tif in temporary:
            os.close(handle)
            _remove_file(temp_tif)
        at.unregister(_remove_file)

    scan_command = ["zbarimg", "--raw", "-q", "-Sdisable", "-Sqrcode.enable"] + image_paths
    result = subprocess.run(scan_command, capture_output=True)
    for line in result.stdout.split(b"\n"):
        if line != b'':
            yield line

def webcam_restore(use_display):
    if not program_present("zbarcam"):
        logging.fatal("zbarcam not found. install 'zbar' to scan using your camera.")
        sys.exit(2)

    scan_command = ["zbarcam", "--raw", "-Sdisable", "-Sqrcode.enable"]
    if not use_display:
        scan_command.append("--nodisplay")

    with subprocess.Popen(scan_command, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL) as proc:
        while True:
            line = proc.stdout.readline()
            if line == b'':
                return
            if (yield line.strip()):
                return

def expected_codes_type(_, counts, code_type): # Returns a list of binary strings
    num_normal = counts[b'N']
    assert num_normal is not None
    code_digits = math.ceil(math.log(num_normal+1,10))

    num_type = counts[code_type]
    if code_type == b'P' and num_type is None:
        num_type = erasure_count(DEFAULT_ALLOWABLE_LOSS)
    return [code_type + f"{i:>0{code_digits}}".encode('ascii') for i in range(1, num_type+1)]
    
def expected_codes(_, counts, use_erasure=None): # Returns a list of binary strings
    num_normal = counts[b'N']
    if num_normal is None:
        return None
    if use_erasure is None:
        use_erasure = counts[b'P'] is not None

    code_digits = math.ceil(math.log(num_normal+1,10))
    normal, erasure = expected_codes_type(_, counts, b'N'), []
    if use_erasure:
        erasure = expected_codes_type(_, counts, b'P')
    else:
        erasure = []
    return normal + erasure

def restore_status(codes, counts, use_erasure=None):
    if counts[b'N'] is None:
        return f"{len(codes)}/??? codes read"
    else:
        expected = expected_codes(codes, counts, use_erasure=use_erasure)
        missing = [x.decode('ascii') for x in expected if x not in codes]
        return f"Missing {len(missing)}/{len(expected)} codes: " + ' '.join(x[1:] for x in missing[:5]) + (" ..." if len(missing) > 5 else "")

def is_complete(codes, totals, extra_wanted=0, use_erasure=None):
    # TODO: Logic is wrong for >256 block codes.
    # The correct solution is to carefully lay out: you need any 177 codes out of these 256, 177 out of these 256, and 120 out of these 150.
    # Instead, we just say "yes" once it's even vaguely plausible. If we try to restore and it fails, we up the number.
    if totals[b'N'] is None:
        return False
    logging.info("{}/{}? complete".format(len(codes), totals[b'N']))
    return len(codes) > totals[b'N'] + extra_wanted

def do_restore(codes, totals, use_erasure, use_compression, use_encryption, encryption_passphrase):
    assert is_complete(codes, totals, use_erasure=use_erasure)

    # Base-64 decode (per qr-code)
    decoded = {k: base64.b64decode(v) for k,v in codes.items()}

    if use_erasure:
        # Erasure decode
        normal_codes  = [decoded.get(expected_code) for expected_code in expected_codes_type(codes, totals, b'N')]
        erasure_codes = [decoded.get(expected_code) for expected_code in expected_codes_type(codes, totals, b'P')]
        #print(totals, sorted(codes.keys()))
        #print(normal_codes, erasure_codes)
        content = restore_erasure(normal_codes, erasure_codes, DEFAULT_ALLOWABLE_LOSS)
    else:
        # Concat
        content = b''.join(decoded[x] for x in expected_codes(codes, code_count))

    # Remove padding
    content = length_decode(content)

    # Decrypt
    if use_encryption is None:
        use_encryption = content.startswith(b"-----BEGIN PGP MESSAGE-----")
    if use_encryption is True:
        content = decrypt(content, encryption_passphrase)

    # Decompress
    if use_compression is True:
        content = gzip.decompress(content)
    elif use_compression is None: # automatic determination
        try:
            content = gzip.decompress(content)
            use_compression = True
        except gzip.BadGzipFile:
            use_compression = False

    return content

def main_restore(args):
    # Default config
    restore_method = None # Should be one of: None, "webcam", "images"

    output_path = None # Should be one of: None (for use_stdout), file path
    use_stdout = False
    totals = {b'N': None, b'P': None} # Values should be one of: None (infer) or a number
    use_display = True

    expected_sha256sum = None
    use_compression = None
    use_encryption = None
    encryption_passphrase = None
    use_erasure = None

    # Parse command-line arguments
    pargs = []
    while len(args) > 0:
        arg, args = args[0], args[1:]
        if arg in ["-h", "--help"]:
            show_help()
        elif arg == "--code-count-erasure":
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            totals[b'P'], args = int(args[0]), args[1:]
        elif arg == "--code-count-normal":
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            totals[b'N'], args = int(args[0]), args[1:]
        elif arg == "--compress":
            use_compression = True
        elif arg == "--display":
            use_display = True
        elif arg == "--encrypt":
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            use_encryption = True
            encryption_passphrase, args = args[0], args[1:]
        elif arg == "--image-restore":
            restore_method = "images"
        elif arg == "--no-compress":
            use_compression = False
        elif arg == "--no-encrypt":
            use_encryption = False
        elif arg == "--no-display":
            use_display = False
        elif arg in ["-o", "--output"]:
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            output_path, args = args[0], args[1:]
        elif arg == "--sha256":
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            expected_sha256sum, args = args[0].lower(), args[1:]
            if not all(x in "0123456789abcdef" for x in expected_sha256sum) or len(expected_sha256sum) > 64:
                show_help("Not a valid SHA256: {}".format(expected_sha256sum))
        elif arg in ["-v", "--verbose"]:
            logging.basicConfig(level=logging.INFO)
        elif arg == "--webcam-restore":
            restore_method = "webcam"
        elif arg == "-":
            pargs.append(arg)
        elif arg == "--":
            # Stop parsing arguments
            pargs, args = pargs + args, []
        elif arg.startswith("-"):
            show_help()
        else:
            pargs.append(arg)

    assert len([x for x in pargs if x == "-"]) <= 1, "stdin can be listed as an image only once"
    if restore_method is None and len(pargs) == 0 and not sys.stdin.isatty():
        logging.debug("Reading from stdin")
        restore_method = "images"
        pargs = ["-"]
    elif restore_method is None and len(pargs) == 0:
        restore_method = "webcam"
    elif restore_method is None and len(pargs) > 0:
        restore_method = "images"

    if output_path is None:
        use_stdout = True

    if use_encryption and not program_present("gpg"):
        show_help("gpg must be installed to use --encrypt. could not find gpg in the PATH")

    # Call a subprocess to do the restore
    if restore_method == "images":
        logging.info("image restore selected")
        restore_generator = image_restore(pargs)
    elif restore_method == "webcam":
        logging.info("webcam restore selected")
        restore_generator = webcam_restore(use_display=use_display)
    else:
        assert False

    # Scan codes one at a time until done
    codes = {}
    codes_by_type = {b"N":set(), b"P": set()}
    extra_wanted = 0
    while True:
        # Print status line
        if restore_method == "webcam":
            if totals[b'N'] is None:
                print("Hold up QR codes to the webcam in any order.",file=sys.stderr)
            else:
                print(restore_status(codes, totals, use_erasure=use_erasure),file=sys.stderr)

        # Read the next code as binary data
        try:
            # TODO: Is there any reason not to just read every code from the image immediately? Re-re do this logic to be simpler post-erasure, I think.
            read_code = next(restore_generator)
        except StopIteration:
            logging.fatal("Not enough codes could be read to restore the file. Exiting.")
            sys.exit(3)

        # Parse the label out
        assert b"\n" not in read_code
        code_label, content = read_code.split(b' ', maxsplit=1)
        code_type, (code_num, total) = code_label[0:1], code_label[1:].split(b'/')
        code_num = code_type + code_num
        total = int(total.decode('ascii'))

        if totals[code_type] is None:
            totals[code_type] = total
        elif totals[code_type] == total:
            pass
        elif totals[code_type] != total and len(codes_by_type[code_type]) == 0: # xxx: len(normal_codes) == 0
            option = {b'N': "--code-count-normal", b'P': "--code-count-erasure"}
            logging.fatal("Code count disagrees with {option} option (Code={}, {option}={})".format(code_label.decode('ascii'), totals[code_type], option=option))
            sys.exit(4)
        elif totals[code_type] != total and len(codes_by_type[code_type]) != 0:
            logging.fatal("Code count disagrees for codes: {} & {}".format(code_label, next(iter(codes_by_type[code_type]))))
            sys.exit(4)
        else:
            assert False
        assert totals[code_type] is not None

        # Add the code
        if code_num in codes and codes[code_num] == content:
            logging.info(f"Read duplicate code {code_num}: IDENTICAL")
        elif code_num in codes and codes[code_num] != content:
            logging.error(f"Read duplicate code {code_num}: DIVERGES")
        elif code_num not in codes:
            logging.info(f"Read new code {code_num}")
        else:
            assert False
        codes[code_num] = content
        codes_by_type[code_type].add(code_num)

        if is_complete(codes, totals, extra_wanted, use_erasure=use_erasure): # More complicated - no specific set of codes
            # Erasure coding
            if use_erasure is None:
                use_erasure = totals[b'P'] is not None

            # Do the restore
            try:
                content = do_restore(codes, totals, use_compression=use_compression, use_encryption=use_encryption, encryption_passphrase=encryption_passphrase, use_erasure=use_erasure)
                break
            except reedsolo.ReedSolomonError:
                logging.info("Tried decoding. Requesting more codes")
                # Request more codes
                assert totals[b'N'] is not None
                max_extra_wanted = erasure_count(totals[b'N'], DEFAULT_ALLOWABLE_LOSS)
                if extra_wanted == max_extra_wanted:
                    logging.fatal("Invalid number of parity codes expected")
                extra_wanted = min(extra_wanted+10, max_extra_wanted)

    # Close subprocess
    try:
        # TODO: Sometimes one extra code needs to be read before it closes, fix that.
        next(restore_generator, True)
    except StopIteration:
        pass

    # Check the checksum
    sha256sum = hashlib.sha256(content).hexdigest()
    exit_status = 0
    logging.info("restored sha256sum: {}".format(sha256sum))
    if expected_sha256sum is None:
        logging.debug("no expected sha256sum was given")
        print(f"sha256sum was as follows, please check against your paper backup: {sha256sum}", file=sys.stderr)
    elif expected_sha256sum == sha256sum:
        logging.debug("sha256sum matched")
        #print("File verified using sha256 checksum.", file=sys.stderr)
    elif sha256sum.startswith(expected_sha256sum):
        logging.debug("sha256sum partial matched")
        print(f"The actual sha256sum begins with checksum given on the command line, but it was not complete. The full checksum was: {sha256sum}", file=sys.stderr)
    else:
        logging.error("sha256sum did not match")
        exit_status = 4
        print(f"!!The restored file does NOT match the expected checksum. Restoring anyway.", file=sys.stderr)

    # Write the output
    if use_stdout:
        sys.stdout.buffer.write(content)
    else:
        with open(output_path, "wb") as f:
            f.write(content)
    sys.exit(exit_status)

if __name__ == "__main__":
    # parse command-line arguments
    args = sys.argv[1:]
    if len(args) >= 1 and args[0] in ["-r", "--restore"]:
        main_restore(args[1:])
    else:
        main_backup(args)
